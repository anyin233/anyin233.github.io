<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小牛uqi2022改装记录</title>
    <link href="/2023/10/19/lji-ebike-controller/"/>
    <url>/2023/10/19/lji-ebike-controller/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要改装">为什么要改装</h1><p>众所周知的是，在中国，多数的省会都是禁摩的，为了回应禁摩政策，满足广大人民群众的出行需求，电瓶车这种抽象玩意儿走入了人们的视野。与之同时，国内为了回应电瓶车这种抽象玩意儿的发展，提出了更加抽象的玩意儿：新国标电动自行车。</p><span id="more"></span><p>新国标电动自行车存在几个限制：55kg整车重量、25km/h最大时速、15km/h以上必须嘀嘀嘀叫。在这些限制下，国内新销售的新国标电动自行车变得更为抽象，必须要在奇怪的地方阉割来满足其要求，比如缩车架、缩避震、缩电池、缩坐垫，但是考虑到人民群众的真实需求，一系列400w高性能电机横空出世，使得原本不富裕的车辆配置显得更加抽象。</p><p>我所购买的是小牛所推出的uqi2022，这款车原装状态整备重量55 + 10kg、400w * 3电机、48V32Ah三元锂电池。与这款车强劲动力和优秀电池相反的是，这款车的避震只能用铁棍来形容，轮胎也因为重量限制能细则细，控制器按照小牛传统艺能：能用，但是不好用，这使得其不得不进行改装以提升驾乘体验。</p><h1 id="改装过程">改装过程</h1><h2 id="轮胎">轮胎</h2><p>小牛原厂轮胎为75-85-12的朝阳神鸟金乌OEM版轮胎，相对于零售版本其缩减为了4层，速度等级48J，轮胎本身具有优秀的抓地力，但是奈何原厂轮胎过于细小，在经过某些特殊地形的时候会出现严重的打滑。</p><p>在仔细研究了摩托车轮胎、轮辋国标以及各大品牌轮胎的性能、适用范围、寿命和价格之后，我选择为我的车安装90-90-12尺寸的米其林city grip saver。这款轮胎是米其林推出的一款针对电动摩托车设计的轮胎，按照米其林的宣传，这款轮胎能够在提供city grip系列最高的抓地力的同时拥有该系列最优秀的能量节约效果。</p><p>在安装该轮胎后，车辆的稳定性的确得到了大幅提升，按照互联网上的信息多数人在更换90-90-12尺寸轮胎后车辆续航都会有10%~20%的下降，但是在更换该轮胎后车辆续航并未发生下降，这也是这个轮胎超越期望的一点。</p><h2 id="避震">避震</h2><p>小牛原厂前避震孔距为330，在更换90-90-12轮胎后由于提高了挡泥板高度，导致挡泥板容易与三星柱产生碰撞，故需要将前避震更换为更长的避震，且由于前避震长度增加，后避震长度也需要对应进行提升，故前后避震同时进行了更换。</p><p>前避震选择了比博士的gx1，后避震选择了黑名单的避震。长度选择为前375后380，这样的长度选择能够保证车辆的倾斜程度不会有太大的改变，并且相对于原厂的小铁棍拥有更加优秀的滤震效果。</p><p>改装的过程中需要注意的一点是小牛u2的前刹车卡钳的孔距为40mm，而多数的避震提供的孔距都是43mm的，这使得二者不匹配，且安装角度也相互不匹配，在使用常规避震的时候需要使用专用转接码，这类转接码通常价格在50左右，使用该类转接码之后也不需要花高价去购买直上避震了。</p><h2 id="控制器">控制器</h2><p>小牛原厂控制器那叫一个一言难尽，转把不线性、动力回收效果很迷。而在2023年的一天，九号旗下的零极创新所推出的鼹鼠控居然适配了小牛，这不得狠狠地尝试了。</p><p>我选择的鼹鼠控e210是在售的鼹鼠控中唯一一款为电动自行车设计的控制器，这个控制器的最大放流为100A，最大电压为84v，可以说是一款参数上相当粗暴的控制器。控制器刷上小牛固件之后总共有两个挡位，分别为经济档和激进档，二者分别对应了不同的加速策略和动能回收策略，速度上限相同。且这个控制器还提供了包括tcs和hhc在内的使用功能，tcs即牵引力控制功能，其可以降低车辆打滑的可能性，hhc为坡道驻车，其使得车辆能稳稳地自己停在坡道上。</p><p>实际上车之后能够明显感觉到转把相对于更换控制器之前更加线性，动能回收的体验也更加舒适，多数情况下可以不需要刹车，仅依赖动能回收完成停车，且车辆续航也得到了提升。美中不足的是这款控制器可能是为了照顾动力版用户，动力调教不如原厂控制器激进，但是多数情况下也不需要如此激进的动力。</p><h1 id="未来计划">未来计划</h1><p>目前车辆令我不满意的地方只剩下储物空间和坐垫了。在预算允许的情况下，在未来可能会为车辆安装一体坐，并加装尾箱来进一步增加车辆储物空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>新国标电自</tag>
      
      <tag>改装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录如何解决更新PVE后apt编译某dkms模块出错</title>
    <link href="/2023/09/27/dkms-build-error-after-upgrade/"/>
    <url>/2023/09/27/dkms-build-error-after-upgrade/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述">问题描述</h1><p>在PVE从7更新至8后，内核版本得到了更新，至此我再也不需要通过安装非官方支持的内核来提供对我所使用的核显的支持。但是更新后由于kernel版本更新到了6.2.16，同时编译器可能发生了某些变化，导致在PVE7使用过程中安装的用于支持sriov的内核模块无法正常通过编译，导致每次执行apt都会陷入漫长的编译中并失败。</p><h1 id="解决方案">解决方案</h1><p>由于目前这台机器未来将会作为专用的软路由设备，故不再需要通过sriov实现核显的虚拟化，解决上述问题只需要移除这个dkms模块即可</p><p>如果直接执行<code>dkms remove i915-sroiv-dkms/6.2</code>可以看到系统会提示该模块并未被安装到当前的内核中，自动跳过，遇到这种情况只需要将命令改为<code>dkms remove i915-sroiv-dkms/6.2 --all</code>即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>PVE</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宁芝静电容键盘体验</title>
    <link href="/2023/05/24/Niz-Keyboard-Exp/"/>
    <url>/2023/05/24/Niz-Keyboard-Exp/</url>
    
    <content type="html"><![CDATA[<h2 id="购买动机">购买动机</h2><p>由于编码需求日渐提升，MacBook自带的键盘过于敲钢板，故开始着眼于购买一把新的键盘用于日常输入。在仔细研究当前的键盘市场以及遭到某位客制化狂魔洗脑后，我购入了一把Keychron的Q1 Pro，并将其轴体更换为了TTC的钢铁红轴。虽然输入体验相较于内置键盘提升巨大，但是对于我来说45g的键盘还是些许不适合长时间进行输入。在对键盘圈进行进一步了解之后，我逐渐看上了静电容键盘，这一类键盘的评价两极分化，有的人说这是最后的退烧键盘，有的人说这只是单纯的高级薄膜键盘罢了。而对于键盘的手感问题一直都是一个主观问题，选择一把适合自己的键盘最好的办法就是去体验它，故我决定购买一把静电容键盘用于日常输入体验。</p><p>市面上常见的成品静电容键盘主要有三家，分别为大名鼎鼎的HHKB、RealForece和Niz。前两者的价格都在两千左右，而Niz则位于一千左右。作为一个预算有限的学生党，处于能省则省的原则，在多方了解Niz的评价和体验后，我选择了购买Niz最新推出的35g单模版本Mini84键盘。</p><h2 id="键盘介绍">键盘介绍</h2><p>Mini84的配列是一种不常见的配列，该配列中F键区紧挨着数字键区，并且并未与数字键错位，同时方向键和功能键也紧挨主键盘区域，整个键盘几乎看不到空白的区域。对于这种紧凑的配列我表示非常满意，其在一定程度上减少了手腕的移动，虽然赶不上HHKB那种更为极端的配列，但是Niz的这个配列在我看来是一个在便携和便于输入之间找到了一个相对优秀的平衡的配列。</p><p>键盘的触发方式就是大名鼎鼎的静电容，基本的结构和Topre一致，均由弹簧、胶碗和导柱三部分构成，主要的手感由胶碗提供。按照网络上的说法，该种结构由于不存在任何的物理触点，故其拥有一般机械键盘难以达到的寿命，但是个人认为其随着时间的推移，内部的胶碗可能会出现一定的老化导致手感发生衰退，在某种程度上也算是限制了整把键盘的寿命。</p><p>键盘默认拥有四层定义，其中第一层即Office层不允许自定义，其余三层均可以通过专用软件进行修改，有一点不好的就是这个软件只提供了Windows版本，希望商家未来可以提供在macOS上使用的专用软件以方便Mac用户。</p><h2 id="键盘体验">键盘体验</h2><blockquote><p>体验方面相对主观，仅供参考</p></blockquote><h3 id="硬件体验">硬件体验</h3><p>Niz的静电容键盘一大争议点就是在于其键盘按下的适合所产生的沙沙沙声，这种声音主要来自于导柱和外壳的摩擦，只要进行简单的润滑便可以解决，在我自己使用的体验看来这种声音似乎并不会对手感产生太大的影响，但是如果追求极致静音建议还是对导柱进行简单的润滑以降低摩擦的声音。</p><p>这把键盘敲击时会产生轻微的段落感，这种段落感类似于某些具有轻微段落感的静音机械轴，触底的时候有轻微的回弹感，不会有那种震手的感觉。这把键盘的大键按照网友的说法是得到了专门的升级的，个人体验上我这把键盘的大键的确也不会有网络上所说的宁芝键盘大键不稳的问题，大键不管是稳定性还是手感都优于我的Q1 Pro和更早时候购买的阿米洛樱花一代。</p><p>输入的过程中35g的压力也并不会出现误触发的情况，手指也可以很自然地搭在上面休息。虽然键盘整体高度较矮，但是还是建议搭配手托进行输入。</p><h3 id="配套软件">配套软件</h3><p>键盘自身自带了大量的调节快捷键，基于这些快捷键已经可以实现很多的功能，然而如果希望使用另外三层的自定义键就必须使用配套软件对其进行调节。</p><p>基础自带的改键快捷键已经提供了很多常用的改键选项，例如Win/Mac配列切换、CapsLock与Ctrl交换等等，切换方式均印刷在键帽上方便查看，这样唯一的缺点就是键帽上略显杂乱，不过未来可以通过更换键帽进行解决。</p><p>在配套软件的获取方面，宁芝只提供了找经销商获取这一条途径，这点与不少大厂可以直接在官网下载的体验相差甚远，也不知道啥时候能解决一下。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录一次宿舍NAS的搭建</title>
    <link href="/2023/02/21/new-nas-build/"/>
    <url>/2023/02/21/new-nas-build/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备">前期准备</h1><h2 id="起因与需求">起因与需求</h2><p>为了不被叔叔恶心，同时简化自己的追番流程，另外还考虑到可以整点homelab，故选择了在宿舍搭建自己的第一台nas，主要目的当然是方便自己进行高画质追番，次要的目的就是随时可以搞点奇奇怪怪的东西来玩。</p><p>既然是宿舍装机，那需求和限制都非常明确</p><ul><li>7 * 24h 运行</li><li>静音</li><li>小体积</li><li>功率低于3200w</li><li>可用容量至少有个8T</li></ul><span id="more"></span><h2 id="硬件选择">硬件选择</h2><p>既然考虑到静音，同时还需要一定的性能拿来搞homelab，那么N5105就被喜闻乐见地排除掉了，毕竟这玩意儿的虚拟化存在一系列的问题，经过反复纠结（高性能AIO、低功耗妖板）后，选定如下配件</p><ul><li>CPU: i3-12100</li><li>主板: 华南 B660M-plus</li><li>内存: 金百达 8G✖️2 3200Mhz intel专用条</li><li>启动盘: 金百达 k230 Pro 500G</li><li>散热器: 利民 AXP90-X36</li><li>电源: 安钛克 HCG 550</li><li>机箱: 御夫座</li><li>存储盘: 希捷VX015 4T✖️4</li></ul><p>上面的配置里面华南的板子只有两个风扇位置能够调速，其中一个是CPU风扇，另一个为机箱风扇，考虑到御夫座机箱的分区设计，可调速的风扇位连接机箱上半层，不可调速的则使用减速线降低转速以降低噪音。</p><h2 id="系统选择">系统选择</h2><p>既然准备未来的扩展性，同时参考了网络上大量的现成案例，最终PVE作为基础系统（原计划unraid，但是不知道为啥无法从我的u盘启动），在其中安装TrueNAS作为文件存储（原计划选择OMV，奈何不支持btrfs的大多数特性，ZFS更别说了），剩余服务均在PVE中使用LXC容器实现。</p><p>目前已经配置完成的服务结构如下</p><ul><li>PVE<ul><li>TrueNAS</li><li>LXC<ul><li>Jellyfin</li></ul></li><li>LXC<ul><li>qbittorrent</li><li>Auto_Bangumi</li></ul></li><li>LXC<ul><li>ChineseSubFinder</li></ul></li></ul></li></ul><p>所有LXC均使用smb挂载TrueNAS创建的存储池以实现媒体库共享。</p><h1 id="系统安装">系统安装</h1><blockquote><p>硬件的安装暂时给省了，直接进行系统安装</p></blockquote><h2 id="pve">PVE</h2><p>PVE的安装过程最为简单，从官网下载安装镜像并使用rufus或者Etcher刷入U盘中，使用U盘启动后按照安装程序的指示继续即可，在该过程中设置的密码便是你的PVE管理员密码，邮箱随意，看起来没啥用的样子。</p><p>安装完毕后重启，在命令行中可以看到你的PVE的后台管理地址，使用另外一台在同一网络下的电脑访问这个地址，便可以进入PVE的后台管理界面。</p><p>安装完毕后需要在PVE中进行几个配置以提升使用体验</p><blockquote><p>此处我将PVE安装在SSD上，后续SATA控制器将会被直通给TrueNAS</p></blockquote><h3 id="iommu">IOMMU</h3><p>为了实现硬件直通，IOMMU必须被开启，开启方法较为简单，只需修改<code>/etc/default/grub</code>，将</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">GRUB_CMDLINE_LINUX_DEFAULT</span>=<span class="hljs-string">&quot;quiet&quot;</span><br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">GRUB_CMDLINE_LINUX_DEFAULT</span>=<span class="hljs-string">&quot;quiet intel_iommu=on i915.enable_guc=7&quot;</span><br></code></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">update-grub<br></code></pre></td></tr></table></figure><h3 id="sriov">SRIOV</h3><p>SRIOV是来自Intel的虚拟化技术，通过这个技术可以把网卡或者其他支持的设备虚拟化成多个设备使用。此处使用该技术将核显虚拟化成8个核显以直通给更多的设备以便后续使用。</p><blockquote><p>一般的主板均开启了该功能，但是还是请检查一下你的主板或者平台是否支持，赛扬和奔腾平台暂时别考虑了，不支持的。</p></blockquote><p>由于此处我使用的是12代Intel CPU，故需要将Linux 内核更新到较高版本以确保支持，对于我的PVE，我将其内核更新至6.1.0。使用如下命令进行更新</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span> update &amp;&amp; apt install pve-kernel-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>-pve<br></code></pre></td></tr></table></figure><p>然后安装对应的headers</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span> install pve-headers-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>-pve<br></code></pre></td></tr></table></figure><p>安装完毕后先进行重启，此时可以使用<code>uname -a</code>确认内核是否更新成功。</p><h4 id="安装i915-sriov-dkms">安装i915-sriov-dkms</h4><p>使用sriov特性需要特定的内核模块，首先安装dkms以便于安装模块。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> dkms -y<br></code></pre></td></tr></table></figure><p>接下来下载<code>i915-sriov-dkms</code>并想办法上传到PVE中，<sub>我把我手上的那个文件弄丢了，丢人</sub></p><p>其中一个比较方便的方法是先将下载得到的<code>i915-sriov-dkms</code>后缀名改为iso，并从PVE上传iso的位置进行上传，此时文件将会出现在<code>/var/lib/vz/template/iso/</code>下，将其移动到主目录下后解压即可进行安装。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mv <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/vz/</span>template<span class="hljs-regexp">/iso/i</span>915-sriov-dkms.tar.iso  i915-sriov-dkms.tar<br>tar -xvf i915-sriov-dkms.tar<br>mv i915-sriov-dkms <span class="hljs-regexp">/usr/</span>src<br>dkms install -m i915-sriov -v dkms<br></code></pre></td></tr></table></figure><p>安装完成后记得检查是否安装成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dkms status</span><br></code></pre></td></tr></table></figure><p>若成功则会有如下输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i915</span>-sriov, dkms, <span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>-pve, x86_64: installed<br></code></pre></td></tr></table></figure><h4 id="修改内核参数">修改内核参数</h4><p>上面在开启IOMMU的时候添加了一个<code>i915.enable_guc=7</code>，这个便是此处开启sriov所需要的内核参数。同时在<code>/etc/kernel/cmdline</code>下面添加如下的内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">intel_iommu</span>=on i915.<span class="hljs-attribute">enable_guc</span>=7 <br></code></pre></td></tr></table></figure><p>如果没这个文件创建一个就好。</p><p>执行如下指令更新内核initramfs</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span>-initramfs -u -k <span class="hljs-keyword">all</span><br>pve-efiboot-tool <span class="hljs-keyword">refresh</span><br></code></pre></td></tr></table></figure><p>然后重启设备。</p><p>重启完毕后建议检查是否有对应的i915固件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/lib/</span>firmware<span class="hljs-regexp">/i915/</span>tgl_guc_70.<span class="hljs-number">1.1</span>.bin<br></code></pre></td></tr></table></figure><p>如果没有的话可以在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/i915/">这里</a>下载，下载后记得再重启一次。</p><h4 id="添加启动参数">添加启动参数</h4><p>完成上面的配置后，可以准备添加启动参数使得开机的时候自动进行虚拟化</p><p>首先需要安装sysfsutils</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> sysfsutils<br></code></pre></td></tr></table></figure><p>然后添加启动参数</p><p>首先使用<code>lspci</code>确认你的显卡pcie地址</p><p>找到其中含有VGA和Intel字样的行，例如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">0</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br></code></pre></td></tr></table></figure><p>前面的<code>00:02.0</code>即为该设备的地址，</p><p>然后执行，注意其中的<PCI_ADDR>替换为该设备的地址</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;devices/pci0000:00/0000:&lt;PCI_ADDR&gt;/sriov_numvfs = 7&quot;</span> &gt; <span class="hljs-regexp">/etc/</span>sysfs.conf<br></code></pre></td></tr></table></figure><p>重启电脑</p><p>最后可以检查你的sriov是否开启成功，</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lspci</span><br></code></pre></td></tr></table></figure><p>若能看到你冒出了一堆的核显，sriov开启成功</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>.<span class="hljs-number">0</span> Host bridge: Intel Corporation Device <span class="hljs-number">4630</span> (rev <span class="hljs-number">05</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">0</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">1</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">2</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">3</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">4</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">5</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">6</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">02</span>.<span class="hljs-number">7</span> VGA compatible controller: Intel Corporation Device <span class="hljs-number">4692</span> (rev <span class="hljs-number">0</span>c)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">06</span>.<span class="hljs-number">0</span> PCI bridge: Intel Corporation Device <span class="hljs-number">464</span>d (rev <span class="hljs-number">05</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">0</span>a.<span class="hljs-number">0</span> Signal processing controller: Intel Corporation Device <span class="hljs-number">467</span>d (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">0</span>e.<span class="hljs-number">0</span> RAID bus controller: Intel Corporation Volume Management Device NVMe RAID Controller<br><span class="hljs-attribute">00</span>:<span class="hljs-number">14</span>.<span class="hljs-number">0</span> USB controller: Intel Corporation Device <span class="hljs-number">7</span>ae0 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">14</span>.<span class="hljs-number">2</span> RAM memory: Intel Corporation Device <span class="hljs-number">7</span>aa7 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">0</span> Communication controller: Intel Corporation Device <span class="hljs-number">7</span>ae8 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">0</span> SATA controller: Intel Corporation Device <span class="hljs-number">7</span>ae2 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">1</span>c.<span class="hljs-number">0</span> PCI bridge: Intel Corporation Device <span class="hljs-number">7</span>ab8 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">1</span>f.<span class="hljs-number">0</span> ISA bridge: Intel Corporation Device <span class="hljs-number">7</span>a86 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">1</span>f.<span class="hljs-number">3</span> Audio device: Intel Corporation Device <span class="hljs-number">7</span>ad0 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">1</span>f.<span class="hljs-number">4</span> SMBus: Intel Corporation Device <span class="hljs-number">7</span>aa3 (rev <span class="hljs-number">11</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">1</span>f.<span class="hljs-number">5</span> Serial bus controller<span class="hljs-meta"> [0c80]: Intel Corporation Device 7aa4 (rev 11)</span><br><span class="hljs-meta">01:00.0 Non-Volatile memory controller: MAXIO Technology (Hangzhou) Ltd. NVMe SSD Controller MAP1202 (rev 01)</span><br><span class="hljs-meta">02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8125 2.5GbE Controller (rev 05)</span><br></code></pre></td></tr></table></figure><p>至此所有的准备工作完成，准备开始安装所有的应用。</p><h2 id="truenas">TrueNAS</h2><p>在PVE中安装系统的过程较为简单，对应安装镜像可以在<a href="https://www.truenas.com/download-truenas-scale/">官网</a>获取，我选择的是TrueNAS Scale，但是实际上由于我并不需要TrueNAS负责除文件存储以外的服务，实际也可以选择基于BSD开发的TrueNAS Core。</p><p>将下载好的iso文件上传到PVE中，创建一个虚拟机，</p><p><img src="https://i.imgur.com/MiQQ4fT.png" alt="image-20230221113151020" style="zoom:50%;" /></p><p>其中<code>VM ID</code>和<code>Node</code>保持默认即可，<code>Name</code>选择一个便于自己识别的名字，</p><p><img src="https://i.imgur.com/6Ojdmos.png" alt="image-20230221113240119" style="zoom:50%;" /></p><p>ISO image选择刚刚上传的iso文件，剩余保持默认，System部分也可以保持默认，到Disk页面设备类型选择SATA，大小32GB左右即可</p><p><img src="https://i.imgur.com/wwL06B7.png" alt="image-20230221113351589" style="zoom:50%;" /></p><p>核心数量根据你的设备性能分配1～4个核心均可，在这里我选择2个核心</p><p><img src="https://i.imgur.com/tuGHwL5.png" alt="image-20230221113443271" style="zoom:50%;" /></p><p>内存建议多给TrueNAS一点，毕竟是吃内存大户，我分配了8GB</p><p><img src="https://i.imgur.com/NDog3Wo.png" alt="image-20230221113524408" style="zoom:50%;" /></p><p>网络部分保持默认，创建即可。</p><p>创建完毕后不要急着启动，定位到你的虚拟机的Hardware页面，点击Add</p><p><img src="https://i.imgur.com/73S5kvp.png" alt="image-20230221113625096" style="zoom:50%;" /></p><p>选择PCI Device，在其中选中你的核显，并勾选<code>All Functions</code>。</p><p>如果你的方案是直通SATA控制器，此时也需要选择你的SATA控制器，并勾选<code>All Functions</code>以保证其可以正常工作。</p><blockquote><p>注意：在你直通SATA控制器后PVE便无法使用在这个控制器下面的所有硬盘了，如果你的PVE也安装在SATA硬盘中，请参考网络上直通SATA设备的方法</p></blockquote><p>接下来可以启动虚拟机，切换到Console页面，此时就和操作普通的虚拟机一样了，具体安装TrueNAS的教程可以参考网络中安装教程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MPI_Cart_Create 使用方法</title>
    <link href="/2022/12/25/MPI-topology-with-MPI-Cart-Create/"/>
    <url>/2022/12/25/MPI-topology-with-MPI-Cart-Create/</url>
    
    <content type="html"><![CDATA[<p>在使用MPI的过程中可能会涉及到一些针对特定的拓扑关系的模拟情况，如<strong>FOX算法求矩阵乘积</strong>。此时需要涉及到如何简便地模拟出特定的方阵以及元素之间的关系。MPI提供了一套简便地API可以快速地创建出携带所需要的拓扑关系的<code>MPI_Comm</code>。</p><span id="more"></span><h1 id="mpi-process-topology-functions">MPI Process Topology Functions</h1><p>该系列的函数即是MPI中用于处理相关的拓扑关系的相关工具。常用的包括了<code>MPI_Cart_create</code>等方法，具体的API可以参考<a href="https://learn.microsoft.com/en-us/message-passing-interface/mpi-process-topology-functions">MSDN</a>。其中较为常用的包括<code>MPI_Cart_create</code>、<code>MPI_Dims_create</code>等方法。</p><h2 id="mpi_cart_create"><code>MPI_Cart_create</code></h2><p>该方法API如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> MPIAPI <span class="hljs-title function_">MPI_Cart_create</span><span class="hljs-params">(</span><br><span class="hljs-params">        MPI_Comm              comm_old,</span><br><span class="hljs-params">        <span class="hljs-type">int</span>                   ndims,</span><br><span class="hljs-params">        _In_count_(ndims) <span class="hljs-type">int</span> *dims,</span><br><span class="hljs-params">        _In_count_(ndims) <span class="hljs-type">int</span> *periods,</span><br><span class="hljs-params">        <span class="hljs-type">int</span>                   reorder,</span><br><span class="hljs-params">  _Out_ MPI_Comm              *comm_cart</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>其中<code>ndims</code>表示维度数量，<code>dims</code>表示全局的各个维度的大小，<code>periods</code>表示（不知道），<code>reorder</code>表示是否按照划分的小块重新计算rank值。</p><p>使用该方法后产生的<code>MPI_Comm</code>将会携带所需要的维度信息，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Cart_create(MPI_COMM_WORLD, <span class="hljs-number">2</span>, dims, periods, <span class="hljs-literal">false</span>, &amp;cart_comm);<br></code></pre></td></tr></table></figure><p>执行后，<code>cart_comm</code>携带的维度信息为全局为一个<code>dims[0] * dims[1]</code>的矩阵。</p><h2 id="mpi_dims_create"><code>MPI_Dims_create</code></h2><blockquote><p>未使用过，故不确定其真实效果</p></blockquote><h1 id="使用案例">使用案例</h1><p>Fox算法求矩阵乘积</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RIDX(i, j, dim) (i * dim + j)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">256</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> rank_num, world_size;<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank_num);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pow</span>(<span class="hljs-type">int</span>(<span class="hljs-built_in">sqrt</span>(world_size)), <span class="hljs-number">2</span>) != world_size) <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong world size\n&quot;</span>);<br><br><br>    <span class="hljs-type">int</span> proc_sqrt = <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(static_cast&lt;<span class="hljs-type">double</span>&gt;(world_size)));<br>    <span class="hljs-type">int</span> n = N / proc_sqrt; <span class="hljs-comment">// N is big matrix size</span><br>    <span class="hljs-type">int</span> n_sqrt = n * n; <span class="hljs-comment">// small matrix size (n * n)</span><br><br>    <span class="hljs-comment">/* check for pragmas */</span><br>    <span class="hljs-keyword">if</span> (world_size &lt; <span class="hljs-number">4</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This algorithm requires at least 4 processors\n&quot;</span>);<br>        MPI_Finalize();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (proc_sqrt * proc_sqrt != world_size)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor count must be square.\n&quot;</span>);<br>        MPI_Finalize();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (N % proc_sqrt !=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;N mod procs_sqrt !=0  &quot;</span>);<br>        MPI_Finalize();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rank_num == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Computing %d * %d matrix, submatrix size is %d * %d\n&quot;</span>, N, N, n, n);<br>    &#125;<br><br>    <span class="hljs-comment">/* create matrixs */</span><br>    <span class="hljs-type">int</span> *A = new <span class="hljs-type">int</span>[n_sqrt];<br>    <span class="hljs-type">int</span> *B = new <span class="hljs-type">int</span>[n_sqrt];<br>    <span class="hljs-type">int</span> *C = new <span class="hljs-type">int</span>[n_sqrt];<br>    <span class="hljs-type">int</span> *T = new <span class="hljs-type">int</span>[n_sqrt];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            A[RIDX(i, j, n)] = (i + j) * rank_num;<br>            B[RIDX(i, j, n)] = (i + j) * rank_num;<br>            C[RIDX(i, j, n)] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* split comm */</span><br>    MPI_Comm cart_comm, cart_col, cart_row;<br>    <span class="hljs-type">int</span> all_rank, col_rank, row_rank;<br>    <span class="hljs-type">int</span> cart_coords[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> dims[<span class="hljs-number">2</span>], periods[<span class="hljs-number">2</span>];<br>    dims[<span class="hljs-number">0</span>] = dims[<span class="hljs-number">1</span>] = proc_sqrt;<br>    periods[<span class="hljs-number">0</span>] = periods[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/* create global node matrix */</span><br>    MPI_Cart_create(MPI_COMM_WORLD, <span class="hljs-number">2</span>, dims, periods, <span class="hljs-literal">false</span>, &amp;cart_comm);<br>    MPI_Comm_rank(cart_comm, &amp;all_rank);<br>    MPI_Cart_coords(cart_comm, all_rank, <span class="hljs-number">2</span>, cart_coords);<br>    <span class="hljs-comment">/* split comm via col &amp; row */</span><br>    MPI_Comm_split(cart_comm, cart_coords[<span class="hljs-number">0</span>], cart_coords[<span class="hljs-number">1</span>], &amp;cart_row);<br>    MPI_Comm_split(cart_comm, cart_coords[<span class="hljs-number">1</span>], cart_coords[<span class="hljs-number">0</span>], &amp;cart_col);<br>    MPI_Comm_rank(cart_row, &amp;row_rank);<br>    MPI_Comm_rank(cart_col, &amp;col_rank);<br><br><br>    MPI_Request req_send, req_recv;<br>    MPI_Status status;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; proc_sqrt; ++i)<br>    &#123;<br>        <span class="hljs-comment">/* swap rows of B */</span><br>        MPI_Isend(B, n_sqrt, MPI_INT, (cart_coords[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> + proc_sqrt) % proc_sqrt, <span class="hljs-number">1</span>, cart_col, &amp;req_send);<br>        <br>        <span class="hljs-type">int</span> broader = (i + cart_coords[<span class="hljs-number">0</span>]) % proc_sqrt;<br>        <span class="hljs-keyword">if</span> (broader == cart_coords[<span class="hljs-number">1</span>]) <span class="hljs-built_in">std</span>::copy(A, A + n_sqrt, T);<br>        <span class="hljs-comment">/* boardcast A */</span><br>        MPI_Bcast(T, n_sqrt, MPI_INT, broader, cart_row);<br><br>        <span class="hljs-comment">/* local mul */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; n; ++c)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)<br>                &#123;<br>                    C[RIDX(r, c, n)] = T[RIDX(r, k, n)] * B[RIDX(k, c, n)];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        MPI_Wait(&amp;req_send, &amp;status);<br>        <span class="hljs-comment">/* finish row swap */</span><br>        MPI_Recv(T, n_sqrt, MPI_INT, (cart_coords[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) % proc_sqrt, <span class="hljs-number">1</span>, cart_col, &amp;status);<br>        <span class="hljs-built_in">std</span>::copy(T, T + n_sqrt, B);<br>    &#125;<br><br>    <span class="hljs-comment">/* gather global matrix */</span><br>    <span class="hljs-type">int</span> *matrixA = new <span class="hljs-type">int</span>[N * N];<br>    <span class="hljs-type">int</span> *matrixB = new <span class="hljs-type">int</span>[N * N];<br>    <span class="hljs-type">int</span> *matrixC = new <span class="hljs-type">int</span>[N * N];<br><br>    MPI_Gather(A, n_sqrt, MPI_INT, matrixA, n_sqrt, MPI_INT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>    MPI_Gather(B, n_sqrt, MPI_INT, matrixB, n_sqrt, MPI_INT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>    MPI_Gather(C, n_sqrt, MPI_INT, matrixC, n_sqrt, MPI_INT, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br><br>    <span class="hljs-keyword">if</span> (rank_num == <span class="hljs-number">0</span>)<br>    &#123;<br><br>        ofstream <span class="hljs-title function_">Af</span><span class="hljs-params">(<span class="hljs-string">&quot;c.data/a.txt&quot;</span>)</span>, <span class="hljs-title function_">Bf</span><span class="hljs-params">(<span class="hljs-string">&quot;c.data/b.txt&quot;</span>)</span>, <span class="hljs-title function_">Cf</span><span class="hljs-params">(<span class="hljs-string">&quot;c.data/c.txt&quot;</span>)</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            &#123;<br>                Af &lt;&lt; matrixA[RIDX(i, j, N)] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>            &#125;<br>            Af &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            &#123;<br>                Bf &lt;&lt; matrixB[RIDX(i, j, N)] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>            &#125;<br>            Bf &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            &#123;<br>                Cf &lt;&lt; C[RIDX(i, j, N)] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>            &#125;<br>            Cf &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br><br>        Af.close(), Bf.close(), Cf.close();<br>    &#125;<br><br><br>    <span class="hljs-comment">/* free resources */</span><br>    MPI_Comm_free(&amp;cart_comm);<br>    MPI_Comm_free(&amp;cart_col);<br>    MPI_Comm_free(&amp;cart_row);<br>    delete[] A;<br>    delete[] B;<br>    delete[] C;<br>    delete[] T;<br>    delete[] matrixA;<br>    delete[] matrixB;<br>    delete[] matrixC;<br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MPI,并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中科大2019.5</title>
    <link href="/2022/03/02/%E4%B8%AD%E7%A7%91%E5%A4%A72019-5/"/>
    <url>/2022/03/02/%E4%B8%AD%E7%A7%91%E5%A4%A72019-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p>给出一个二叉排序树的层次遍历，求从它的一个叶子结点到另一个叶子结点的路径，要求路径上经过结点的数值之和最大。二叉树的层次遍历序列从文件<code>expr.in</code>中读取，结点数值大于0，将结果输出到标准输出中。</p><h2 id="样例">样例</h2><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">15</span> <span class="hljs-number">40</span> <span class="hljs-number">5</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">50</span> <span class="hljs-number">10</span> <span class="hljs-number">35</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">170<br></code></pre></td></tr></table></figure><h1 id="算法思路">算法思路</h1><p>本题对应模板：求树的直径。</p><p>树的直径指的是对于树的任意两个叶子节点最远的距离，即可以简化为对于树中的任意一个节点，到达叶子节点的最长路径和次长路径的长度之和。</p><p>基于这一点，可以将求树的直径转化为两个过程</p><ul><li>从下向上传递（求树高度）</li><li>从上向下传递</li></ul><p>对于自下而上的传递过程，基本的方式和求树的高度相同，但是需要记录次高的路径，但是返回最高的路径。</p><p>对于自上而下的过程，需要明确对于任意节点，最长路径和次长路径只会来源于<code>parent</code>和两个<code>children</code>，故需要将<code>parent</code>的某一个长边传递给当前正在计算的节点。通常情况下传入<code>parent</code>的最长边，但是当<code>parent</code>的最长边经过当前点的时候则使用<code>parent</code>的次长边更新当前节点的信息。同时易证使用<code>parent</code>的最长边（次长边）和当前节点的两个长边更新得到的长边必然可以得到以该节点为中心得到的直径长度（并非全局直径）。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> tree[N], mx[N], mx2[N], mxr[N], mx2r[N]; <span class="hljs-comment">// longest, 2nd longest, next node of longest, next node of 2nd longest</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!tree[u])<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> llen = <span class="hljs-built_in">down</span>(u &lt;&lt; <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> rlen = <span class="hljs-built_in">down</span>((u &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (llen &gt; rlen)<br>        mxr[u] = u &lt;&lt; <span class="hljs-number">1</span>, mx2r[u] = (u &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        mxr[u] = (u &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, mx2r[u] = u &lt;&lt; <span class="hljs-number">1</span>;<br><br>    mx[u] = <span class="hljs-built_in">max</span>(llen, rlen) + tree[u];<br>    mx2[u] = <span class="hljs-built_in">min</span>(llen, rlen) + tree[u];<br>    <span class="hljs-keyword">return</span> mx[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!tree[u])<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mxr[p] != u) <span class="hljs-comment">// parent&#x27;s longest edge doesn&#x27;t contain this node</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (mx[p] &gt; mx[u])<br>            &#123;<br>                mx2[u] = mx[u];<br>                mx[u] = mx[p];<br>                mx2r[u] = mxr[u];<br>                mxr[u] = p; <span class="hljs-comment">// longest edge from parent</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mx[p] &gt; mx2[u])<br>            &#123;<br>                mx2[u] = mx[p];<br>                mx2r[u] = p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (mx2[p] &gt; mx[u])<br>            &#123;<br>                mx2[u] = mx[u];<br>                mx[u] = mx2[p];<br>                mx2r[u] = mxr[u];<br>                mxr[u] = p; <span class="hljs-comment">// longest edge from parent</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mx2[p] &gt; mx2[u])<br>            &#123;<br>                mx2[u] = mx2[p];<br>                mx2r[u] = p;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">up</span>(u &lt;&lt; <span class="hljs-number">1</span>, u);<br>    <span class="hljs-built_in">up</span>((u &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;expr.in&quot;</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; ifs &gt;&gt; tree[i]; i++)<br>        ;<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">up</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j)<br>        res = <span class="hljs-built_in">max</span>(res, mx[j] + mx2[j] - tree[j]);<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 343.排序</title>
    <link href="/2022/02/21/AcWing-343-%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/02/21/AcWing-343-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题的基本思路为基于floyd算法实现传递闭包，即将所有的大小关系进行传递，得到一个全局的大小关系，基于该大小关系判断是否存在矛盾的情况。</p><p>矛盾的情况有两种</p><ul><li><code>A &lt; A &amp;&amp; A &gt; A</code></li><li><code>A &lt; B &amp;&amp; B &lt; A</code></li></ul><p>二者可以在构造整个大小关系图的过程中被逐渐排查出来，即可以一边建图一边检查，当其中出现了任何一个冲突的时候便会终止后续的检查操作，大幅度减少计算量。</p><p>对于最终输出序列的方法，考虑到本题的数据规模较小，可以考虑直接使用暴力枚举的方式，枚举每一个大小关系并标记，直接得到序列。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">30</span>;<br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            &#123;<br>                g[i][j] |= g[i][k] &amp;&amp; g[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <br>        <span class="hljs-keyword">if</span> (g[i][i]) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            <span class="hljs-keyword">if</span> (!g[i][j] &amp;&amp; !g[j][i])<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>            &#125;<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_min</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; g[j][i])<br>                &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag)<br>            &#123;<br>                st[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n || m)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> g);<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-type">int</span> typ = <span class="hljs-number">0</span>, t;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; m; ++i)<br>        &#123;<br>            <span class="hljs-type">char</span> a[<span class="hljs-number">4</span>];<br>            cin &gt;&gt; a;<br>            <br>            <br>            <span class="hljs-keyword">if</span> (!typ)<br>            &#123;<br>                g[a[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;A&#x27;</span>][a[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;A&#x27;</span>] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">floyd</span>();<br>                typ = <span class="hljs-built_in">check</span>();<br>                <span class="hljs-keyword">if</span> (typ) t = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!typ) cout &lt;&lt; <span class="hljs-string">&quot;Sorted sequence cannot be determined.\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typ == <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;Inconsistency found after &quot;</span>&lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; relations.\n&quot;</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Sorted sequence determined after &quot;</span>&lt;&lt; t&lt;&lt; <span class="hljs-string">&quot; relations: &quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-built_in">get_min</span>());<br>            cout &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>floyd</tag>
      
      <tag>传递闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 异步与多线程</title>
    <link href="/2022/02/18/Rust-%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/02/18/Rust-%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该文档为个人学习记录，可能存在大量错误</p></blockquote><h1 id="概述">概述</h1><p>Rust中std库实现异步与多线程的方式包括了<code>async/await</code>和<code>thread</code>，二者在官方文档中分别对应了<code>high-level</code>和<code>low-level</code>的场景。</p><span id="more"></span><h1 id="rust中的数据同步">Rust中的数据同步</h1><p>实现多线程必须要考虑到数据同步的问题，Rust给出的解决方案是<code>Mutex&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>，二者可以分别对应到不具备线程安全的<code>RefCell&lt;T&gt;</code>和<code>Rc&lt;T&gt;</code>。两组容器的使用方式基本一致，通常情况下的一个使用实例是<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>从而保证某个共享的数据可以存在多个所有者，同时实现内部可变性。</p><h1 id="stdthread">std::thread</h1><p>该实现方式为 <em>The Book</em> 中讲述的实现方式，最基本的代码实现形式为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的代码实现创建了一个新的线程，并返回对应线程的<code>handler</code>，基于对<code>handler</code>的控制可以实现对该线程的管理。其中<code>handler</code>具有<code>JoinHandler</code>类型，实现了三个有关多线程的方法，分别是<code>join()</code>，<code>thread()</code>和<code>is_running()</code>。其中<code>join()</code>方法使得执行该方法的线程会在执行到<code>handler.join()</code>时阻塞等待线程的退出，<code>thread()</code>返回<code>handler</code>对应的线程信息，<code>is_running()</code>则指示线程是否正在运行。</p><h1 id="asyncawait">async/await</h1><p><strong>TODO</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>程序语言</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 181.回转游戏</title>
    <link href="/2022/02/06/AcWing-181-%E5%9B%9E%E8%BD%AC%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/02/06/AcWing-181-%E5%9B%9E%E8%BD%AC%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>该算法基本大体框架同AcWing.180，但是题目中涉及到的8种操作需要一定的处理技巧</p><h2 id="八种回转操作">八种回转操作</h2><p>首先可以考虑对八种操作进行硬编码，此处采用顺时针从0到7。然后由于题目中传入的数字序列并非便于操作的方式，我们可以进行一个打表操作，提前确定会被影响到的位置。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache">        <span class="hljs-attribute">A</span>     B<br>        <span class="hljs-attribute">0</span>     <span class="hljs-number">1</span><br>        <span class="hljs-attribute">2</span>     <span class="hljs-number">3</span><br><span class="hljs-attribute">H</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">10</span> C<br>        <span class="hljs-attribute">11</span>    <span class="hljs-number">12</span>      <br><span class="hljs-attribute">G</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> D<br>        <span class="hljs-attribute">20</span>    <span class="hljs-number">21</span><br>        <span class="hljs-attribute">22</span>    <span class="hljs-number">23</span><br>        <span class="hljs-attribute">F</span>     E<br></code></pre></td></tr></table></figure><p>即可以生成一个<code>op</code>数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> op[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>] = &#123;<br>  &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>&#125;, <span class="hljs-comment">// A</span><br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span> ,<span class="hljs-number">21</span>, <span class="hljs-number">23</span>&#125;, <span class="hljs-comment">// B</span><br>  &#123;<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, <span class="hljs-comment">// C</span><br>  &#123;<span class="hljs-number">19</span>, <span class="hljs-number">18</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span>&#125;, <span class="hljs-comment">// D</span><br>  &#123;<span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">17</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, <span class="hljs-comment">// E</span><br>  &#123;<span class="hljs-number">22</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, <span class="hljs-comment">// F</span><br>  &#123;<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>&#125;, <span class="hljs-comment">// G</span><br>  &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;, <span class="hljs-comment">// H</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>同样可以生成一个相反操作的数组，防止出现两次相反的操作导致无效操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> opposite = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">24</span>;<br><br><span class="hljs-type">int</span> op[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>] = &#123;<br>  &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>&#125;, <span class="hljs-comment">// A</span><br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span> ,<span class="hljs-number">21</span>, <span class="hljs-number">23</span>&#125;, <span class="hljs-comment">// B</span><br>  &#123;<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, <span class="hljs-comment">// C</span><br>  &#123;<span class="hljs-number">19</span>, <span class="hljs-number">18</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span>&#125;, <span class="hljs-comment">// D</span><br>  &#123;<span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">17</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, <span class="hljs-comment">// E</span><br>  &#123;<span class="hljs-number">22</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, <span class="hljs-comment">// F</span><br>  &#123;<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>&#125;, <span class="hljs-comment">// G</span><br>  &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;, <span class="hljs-comment">// H</span><br>&#125;;<br><br><span class="hljs-type">int</span> oppsite[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> center[] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>&#125;;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> g[N];<br><span class="hljs-type">int</span> path[<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> sum[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(sum, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> sum);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) sum[g[center[i]]] ++;<br>    <br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; ++i) s = <span class="hljs-built_in">max</span>(s, sum[i]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">8</span> - s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> ac)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = g[op[ac][<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) g[op[ac][i]] = g[op[ac][i + <span class="hljs-number">1</span>]];<br>    g[op[ac][<span class="hljs-number">6</span>]] = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u + <span class="hljs-built_in">f</span>() &gt; depth) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (oppsite[i] != last) <span class="hljs-comment">// prevent it goes back</span><br>        &#123;<br>            <span class="hljs-built_in">move</span>(i);<br>            path[u] = i;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, depth, i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">move</span>(oppsite[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; g[<span class="hljs-number">0</span>], g[<span class="hljs-number">0</span>])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i) cin &gt;&gt; g[i];<br>        <br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, depth, <span class="hljs-number">-1</span>)) depth ++;<br>        <br>        <span class="hljs-keyword">if</span> (!depth) cout &lt;&lt; <span class="hljs-string">&quot;No moves needed&quot;</span>;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; depth; ++i) cout &lt;&lt; (<span class="hljs-type">char</span>) (path[i] + <span class="hljs-string">&#x27;A&#x27;</span>);<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; g[center[<span class="hljs-number">0</span>]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
      <tag>IDA*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 180.排书</title>
    <link href="/2022/02/06/AcWing-180-%E6%8E%92%E4%B9%A6/"/>
    <url>/2022/02/06/AcWing-180-%E6%8E%92%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><h2 id="ida">IDA*</h2><p>该算法为A*和迭代加深的结合，其中相对于A*的估价函数额外增加了基于估价函数超过迭代层数的剪枝。</p><h2 id="排书交换">排书交换</h2><p>本题中由于可以一次性将连续的一串书本直接插入到后面的某个位置，故可以考虑从遍历长度入手。</p><p>交换的过程可以如下所示</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">-----</span><span class="hljs-comment">|</span><span class="hljs-literal">-----</span><span class="hljs-comment">|</span><span class="hljs-literal">------</span><span class="hljs-comment">|</span><span class="hljs-literal">--------</span><br>     <span class="hljs-comment">l     r      k</span>   <br></code></pre></td></tr></table></figure><p>整个交换过程可以分为下面几步</p><ul><li>首先将原始的数组<code>b</code>复制一份到备用数组<code>w[depth]</code></li><li>将<code>w[depth]</code>的<code>r + 1</code>到<code>k</code>的部分复制到<code>p</code>的<code>l</code>到<code>l + k - r</code>区域</li><li>将<code>w[depth]</code>的<code>l</code>到<code>r</code>部分复制到<code>p</code>的对应剩余部分。</li><li>...</li></ul><p>在这里我们需要将<code>l</code>到<code>r</code>的书籍插入到<code>r + 1</code>的位置，可以考虑使用如下方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = r + <span class="hljs-number">1</span>, y = l; x &lt;= k; ++x, ++y) b[y] = w[depth][x];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = l; x &lt;= r; ++x, ++y) b[y] = w[depth][x];<br></code></pre></td></tr></table></figure><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">16</span>;<br><br><span class="hljs-type">int</span> b[N], n, c;<br><span class="hljs-type">int</span> w[<span class="hljs-number">5</span>][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b[i] != b[i + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) cnt ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> (cnt + <span class="hljs-number">2</span>) / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b[i] != b[i + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> max_step)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u + <span class="hljs-built_in">f</span>() &gt; max_step) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; ++len)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l + len - <span class="hljs-number">1</span> &lt; n; ++l)<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = r + <span class="hljs-number">1</span>; k &lt; n; ++k)<br>            &#123;<br>                <span class="hljs-built_in">memcpy</span>(w[u], b, <span class="hljs-keyword">sizeof</span> w[u]);<br>                <span class="hljs-type">int</span> x, y;<br>                <span class="hljs-keyword">for</span> (x = r + <span class="hljs-number">1</span>, y = l; x &lt;= k; x ++, y ++) b[y] = w[u][x];<br>                <span class="hljs-keyword">for</span> (x = l; x &lt;= r; x ++, y ++) b[y] = w[u][x];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, max_step)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">memcpy</span>(b, w[u], <span class="hljs-keyword">sizeof</span> w[u]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; c;<br>    <span class="hljs-keyword">while</span>(c --)<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; b[i];<br>        <br>        <span class="hljs-type">int</span> max_step = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(max_step &lt; <span class="hljs-number">5</span> &amp;&amp; !<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, max_step)) max_step ++;<br>        <br>        <span class="hljs-keyword">if</span> (max_step &gt;= <span class="hljs-number">5</span>) cout &lt;&lt; <span class="hljs-string">&quot;5 or more\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; max_step &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
      <tag>IDA*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode LCP33.蓄水</title>
    <link href="/2022/02/06/LeetCode-LCP33-%E8%93%84%E6%B0%B4/"/>
    <url>/2022/02/06/LeetCode-LCP33-%E8%93%84%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>基于给出的操作，即每次操作可以让所有的水桶进行一次注水或者升级<strong>一个</strong>水桶，我们可以考虑使用贪心的思路。<br />由于总共<strong>倒水</strong>的次数取决于需要倒水次数最多的水桶，我们可以考虑采用一个堆，每次取出需要倒水次数最多的那个水桶进行升级，从而最小化倒水的次数。通过不断遍历直到最大的倒水次数只有一次的时候即可跳出升级循环。<br />另外，由于本题中存在容量为0的水缸，为了避免不必要的判断，可以考虑直接进行跳过处理。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">storeWater</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bucket, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vat)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, res = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// upgrade count and result</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, less&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; heap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (bucket[i] == <span class="hljs-number">0</span> &amp;&amp; vat[i] != <span class="hljs-number">0</span>) cnt ++, bucket[i] ++;<br>            <span class="hljs-keyword">if</span> (bucket[i] == <span class="hljs-number">0</span> &amp;&amp; vat[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            heap.<span class="hljs-built_in">push</span>(&#123;(<span class="hljs-type">int</span>)(vat[i] / bucket[i] + (vat[i] % bucket[i] &gt; <span class="hljs-number">0</span>)), i&#125;);<br>        &#125; <span class="hljs-comment">// 预处理，防止出现为0的情况</span><br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span> &amp;&amp; heap.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> p = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> buk = bucket[p.second] + <span class="hljs-number">1</span>, v = vat[p.second];<br>            res = <span class="hljs-built_in">min</span>(res, cnt + p.first);<br>            bucket[p.second] ++; <span class="hljs-comment">// upgrade;</span><br>            cnt ++;<br>            <span class="hljs-keyword">if</span> (v / buk &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <br>            heap.<span class="hljs-built_in">push</span>(&#123;v / buk + (v % buk &gt; <span class="hljs-number">0</span>), p.second&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == <span class="hljs-number">0x3f3f3f3f</span>? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>LCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 170.加成序列</title>
    <link href="/2022/02/05/AcWing-170-%E5%8A%A0%E6%88%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/02/05/AcWing-170-%E5%8A%A0%E6%88%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>迭代加深实际上是DFS中常用的一种剪枝方法。针对某些DFS的情况，其完整DFS的树非常深，但是答案却在较浅的位置时可以使用。常见的命题思路为求一个最短路。</p><p>本题采用迭代加深的算法进行，不断扩大搜索范围（深度），最终得到最短路径。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> depth)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u &gt; depth) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (path[u - <span class="hljs-number">1</span>] == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = u - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-type">int</span> s = path[i] + path[j];<br>            <span class="hljs-keyword">if</span> (s &gt; n || s &lt;= path[u - <span class="hljs-number">1</span>] || st[s]) <span class="hljs-keyword">continue</span>;<br>            <br>            st[s] = <span class="hljs-literal">true</span>;<br>            path[u] = s;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, depth)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st[s] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    path[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)<br>    &#123;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, depth)) depth ++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; depth; ++i)<br>        &#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
      <tag>迭代加深</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode LCP30.魔塔游戏</title>
    <link href="/2022/02/05/LeetCode-LCP30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/02/05/LeetCode-LCP30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>在本题中每次只能将一个负数移动到数列的最后，我们可以考虑维护一个大根堆保存所有的负数，优先移动所有较大的负数可以使得结果最优。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">magicTower</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) sum += nums[i];<br>        <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) heap.<span class="hljs-built_in">push</span>(nums[i]);<br>            <span class="hljs-keyword">while</span> (sum &lt; <span class="hljs-number">0</span> &amp;&amp; heap.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                cnt ++;<br>                nums.<span class="hljs-built_in">push_back</span>(heap.<span class="hljs-built_in">top</span>());<br>                sum -= heap.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">//cout &lt;&lt; sum &lt;&lt; &#x27; &#x27; &lt;&lt; heap.top()&lt;&lt; endl;</span><br>                heap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>LCP</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1219.黄金矿工</title>
    <link href="/2022/02/05/LeetCode-1219-%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/"/>
    <url>/2022/02/05/LeetCode-1219-%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>简单的DFS，由于题目中允许从任意点出发，故需要遍历每一个格子作为起点进行DFS。其余的和常规DFS相同</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> st[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>], <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span>&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>        res = <span class="hljs-built_in">max</span>(res, sum);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> nx = dx[i] + x, ny = dy[i] + y;<br>            <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || ny &lt; <span class="hljs-number">0</span> || nx &gt;= grid.<span class="hljs-built_in">size</span>() || ny &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (st[nx][ny] || grid[nx][ny] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            st[nx][ny] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(nx, ny, grid, st, sum + grid[nx][ny], res);<br>            st[nx][ny] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaximumGold</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> st[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                st[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(i, j, grid, st, grid[i][j], res);<br>                st[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode LCP28.采购方案</title>
    <link href="/2022/02/04/LeetCode-LCP28-%E9%87%87%E8%B4%AD%E6%96%B9%E6%A1%88/"/>
    <url>/2022/02/04/LeetCode-LCP28-%E9%87%87%E8%B4%AD%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><h2 id="暴力tle">暴力（TLE）</h2><p>直接两重循环双指针进行遍历，每遇到一个合法方案就<code>ans++</code></p><h2 id="二分">二分</h2><p>在暴力的基础上，只枚举双指针的前一个指针，后一个指针使用二分查找得到一个最大可行的位置，方案数直接与两个指针相夹的数量相夹即可。</p><h3 id="优化">优化</h3><p>考虑到存在相同报价，可以在遇到相同报价的时候直接复用之前相同报价的方案数，简单地-1即可。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">purchasePlans</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">-1</span>, pre_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-comment">//cout &lt;&lt; pre &lt;&lt; &#x27; &#x27; &lt;&lt; pre_cnt;</span><br>            <span class="hljs-keyword">if</span> (pre &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[pre] &amp;&amp; pre_cnt &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 复用先前的方案</span><br>            &#123;<br>                ans = (ans + pre_cnt) % MOD;<br>                pre_cnt --;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[mid] + nums[i] &gt; target) r = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> l = mid;<br>                mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[r] + nums[i] &lt;= target) ans = (ans + (r - i)) % MOD;<br>            pre = i, pre_cnt = r - i - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>LCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode LCP23.魔术排列</title>
    <link href="/2022/02/04/LeetCode-LCP23-%E9%AD%94%E6%9C%AF%E6%8E%92%E5%88%97/"/>
    <url>/2022/02/04/LeetCode-LCP23-%E9%AD%94%E6%9C%AF%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>需要枚举数字K，当数字K大于等于N的时候结果将会固定 1. 由于第一次抽出的数字必然为<strong>偶数</strong>，当<code>target</code>的第一位数字为奇数的时候必然无法成功 2. K必然小于<code>target</code>序列最开始递增的偶数数量 1. 当<code>target</code>前递增的偶数为数列中全部偶数的时候，还需要注意是否会继续按照数列中的奇数顺序继续枚举 3. 由于题目性质，即抽牌必须按照洗牌后的顺序进行，故第一次计算出来的K即为得到最终正确序列必然的K</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMagic</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target[<span class="hljs-number">0</span>] % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> maxK = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; maxK &lt; target.<span class="hljs-built_in">size</span>() &amp;&amp; <br>        target[maxK] &gt; target[maxK - <span class="hljs-number">1</span>] &amp;&amp; <br>        !(target[maxK] &amp; <span class="hljs-number">1</span>) &amp;&amp; target[maxK] == target[maxK - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>; ++maxK);<br>        <span class="hljs-keyword">if</span> (target[maxK] == <span class="hljs-number">1</span> &amp;&amp; target[maxK - <span class="hljs-number">1</span>] == (target.<span class="hljs-built_in">size</span>() &gt;&gt; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>)<br>        &#123;<br>            maxK ++;<br>            <span class="hljs-keyword">for</span> (; <br>                maxK &lt; target.<span class="hljs-built_in">size</span>() &amp;&amp; <br>                (target[maxK] | <span class="hljs-number">0</span>) &amp;&amp; <br>                target[maxK] == target[maxK - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>; <br>                ++maxK);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; temp, op, after;<br>        <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; target.<span class="hljs-built_in">size</span>(); ++i) op.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; op.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>)<br>            &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(op[i]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; op.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>)<br>            &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(op[i]);<br>            &#125; <span class="hljs-comment">// first step</span><br><br>            op = temp;<br>            temp.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">if</span> (first &amp;&amp; op == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            first = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(maxK, (<span class="hljs-type">int</span>)op.<span class="hljs-built_in">size</span>()); ++i) after.<span class="hljs-built_in">push_back</span>(op[i]);<br>            <span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">size</span>() &gt; maxK) op.<span class="hljs-built_in">erase</span>(op.<span class="hljs-built_in">begin</span>(), op.<span class="hljs-built_in">begin</span>() + maxK);<br>            <span class="hljs-keyword">else</span> op.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> after == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>不得不吐槽一下LeetCode的编辑器实在难用，<a href="https://leetcode-cn.com/problems/er94lq/">原题链接</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>LeetCode</tag>
      
      <tag>LCP</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1725.可以形成最大正方形的矩形数目</title>
    <link href="/2022/02/04/LeetCode-1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/02/04/LeetCode-1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>还能有什么思路，每个矩形既然只能用于切割一个正方形，那么自然能够切割出最大的边长自然就是短边长度。</p><blockquote><p>本题使用索引的效率比迭代器更高</p></blockquote><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : rectangles)<br>        &#123;<br>            <span class="hljs-type">int</span> temp = <span class="hljs-built_in">min</span>(v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (temp &gt; maxLen)<br>            &#123;<br>                maxLen = temp;<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp == maxLen)<br>            &#123;<br>                cnt ++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 29.两数相除</title>
    <link href="/2022/02/03/LeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <url>/2022/02/03/LeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p><del>笑死，直接利用右移和左移作为乘二和除以二来用，同时将变量统一采用<code>long long</code>保存，通过将被除数减去<span class="math inline">\(2^n\)</span>倍的除数，累计这个<span class="math inline">\(2^n\)</span>倍最终可以得到结果。</del></p><p>（上面的思路漏看了题目下面的提示，即不允许使用<code>long long</code>）</p><p>由于不允许使用<code>long long</code>，又希望尽可能获得更大的可用数字的绝对值空间（即希望可以让计算的绝对值扩大到<span class="math inline">\(2^{32}\)</span>)，故最终选择所有的减法模拟的除法都使用负数进行计算。</p><h1 id="算法实现">算法实现</h1><h2 id="错误的实现使用了64位整数">错误的实现（使用了64位整数）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend;<br>        <span class="hljs-type">bool</span> flag = (dividend &gt;&gt; <span class="hljs-number">31</span>) != (divisor &gt;&gt; <span class="hljs-number">31</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> aend = <span class="hljs-built_in">abs</span>(dividend), aor = <span class="hljs-built_in">abs</span>(divisor);<br><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = aor, cnt = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(aend &gt;= aor)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (aend &gt;= temp)<br>            &#123;<br>                aend -= temp;<br>                ans += cnt;<br>                <span class="hljs-keyword">if</span> (temp &lt;= <span class="hljs-number">1073741824</span>)<br>                &#123;<br>                    temp += temp;<br>                    cnt += cnt;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                temp &gt;&gt;= <span class="hljs-number">1</span>;<br>                cnt &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-number">2147483647</span>) ans = <span class="hljs-number">2147483647</span>;<br>        <span class="hljs-keyword">return</span> flag ? -ans : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="正确的实现">正确的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>        <span class="hljs-comment">// 特判可能会溢出的情况</span><br>        <span class="hljs-type">bool</span> fix = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (dividend == INT_MIN) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> INT_MAX;<br>            <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INT_MIN;<br>        &#125;<br><br>        <span class="hljs-comment">// 特判被除数为0</span><br>        <span class="hljs-keyword">if</span> (dividend == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 特判除数为1</span><br>        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend;<br>        <span class="hljs-type">bool</span> flag = (dividend &gt;&gt; <span class="hljs-number">31</span>) != (divisor &gt;&gt; <span class="hljs-number">31</span>);<br>        <span class="hljs-type">int</span> aend = dividend &gt; <span class="hljs-number">0</span> ? -dividend : dividend, aor = divisor &gt; <span class="hljs-number">0</span> ? -divisor : divisor;<br><br>        <span class="hljs-type">int</span> temp = aor, cnt = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(aend &lt;= aor)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (aend &lt;= temp)<br>            &#123;<br>                aend -= temp;<br>                ans += cnt;<br>                <span class="hljs-keyword">if</span> (temp &gt;= (INT_MIN &gt;&gt; <span class="hljs-number">1</span>)) <span class="hljs-comment">// 防溢出</span><br>                &#123;<br>                    temp += temp;<br>                    cnt += cnt;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                temp &gt;&gt;= <span class="hljs-number">1</span>;<br>                cnt &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> flag ? -ans : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1414.和为K的最少斐波纳契数字数目</title>
    <link href="/2022/02/03/LeetCode-1414-%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/02/03/LeetCode-1414-%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>考虑采用深度优先搜索的方式进行，由于每个斐波纳契数字均小于前一个数字的两倍（2除外），可以基于这个特性，每次找到小于当前所求总和的最大的斐波纳契数字x，然后<code>总和 -= x</code>，反复迭代之后即可得到结果。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> f[<span class="hljs-number">50</span>], n, ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; f[i] &lt;= k; ++i)<br>        &#123;<br>            f[i + <span class="hljs-number">1</span>] = f[i] + f[i - <span class="hljs-number">1</span>];<br>            n ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinFibonacciNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        n = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">init</span>(k);<br>        <span class="hljs-comment">//cout &lt;&lt; n;</span><br>        <span class="hljs-keyword">while</span>(k)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(f[n] &gt; k) n--;<br>            k -= f[n];<br>            ans ++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k">题目🔗</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 167.木棒</title>
    <link href="/2022/02/03/AcWing-167-%E6%9C%A8%E6%A3%92/"/>
    <url>/2022/02/03/AcWing-167-%E6%9C%A8%E6%A3%92/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题需要考虑几种剪枝方式</p><h2 id="减少枚举方案">减少枚举方案</h2><p>同样从大到小依次进行枚举，由于最终答案中木棍长度固定，从更长的小棍开始枚举可以减少产生方案的数量。</p><h2 id="可行性剪枝">可行性剪枝</h2><p>对于<strong>单根木棍无法整除所有小木棍长度之和</strong>的情况和<strong>加入某根小木棍后总长度超过当前枚举的总长度</strong>的情况均可以直接进行剪枝。</p><h2 id="移除冗余方案">移除冗余方案</h2><ol type="1"><li>由于本题中只需要求出总和，故基于组合数进行枚举</li><li>当某个长度的小木棍无法用于构造答案的时候，直接跳过所有与其等长的小木棍</li><li>当某个小木棍为当前大木棍的第一根木棍的时候，只要其无法构造答案那么该总长度必然无解</li><li>当某个小木棍为当前大木棍的最后一根木棍的时候，只要其无法构造答案那么该总长度必然无解</li></ol><h3 id="对于剪枝方案3的证明">对于剪枝方案3的证明</h3><p>假定构造当前选定的小木棍为n，其作为x的第一根小木棍构造大木棍，<strong>但是最终该总长度不可行</strong>。假设当前方案可行，即存在一个大木棍y，使得n可以作为第一根木棍，由于本题中大木棍无序，交换x和y，最终可以使得n作为x的第一根木棍，与前面矛盾，故作为剪枝方案。</p><h3 id="对于剪枝方案4的证明">对于剪枝方案4的证明</h3><p>若小木棍n的长度作为大木棍x的最后一根木棍长度，<strong>但是此时该总长度不可行</strong>。可以知道如果<strong>总长度可行</strong>的情况下，x的最后部分必然可以由多个总长度与n相同的木棍构成，此时n实际上可以和这些小木棍实现等价替换，与前面矛盾，故同样可以作为剪枝方案。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">70</span>;<br><span class="hljs-type">int</span> n, w[N], length, sum;<br><span class="hljs-type">bool</span> st[N];<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> start)</span> <span class="hljs-comment">// 当前已经构造了u根木棍，当前正在构造的木棍长度为s，下一步从start开始(剪枝)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u * length == sum) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (s == length) <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (s + w[i] &gt; length) <span class="hljs-keyword">continue</span>;<br>        <br>        st[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(u, s + w[i], i + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        st[i] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 冗余方案剪枝方案3，采用w[i]作为第一根木棍但是全局失败，则剩余方案均无序进行枚举</span><br>        <span class="hljs-keyword">if</span> (s + w[i] == length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 冗余方案剪枝方案4，即采用w[i]作为最后一根失败，但是w[i]可以作为最后一根</span><br>        <br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; w[j] == w[i]) j ++;<br>        i = j - <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n, n != <span class="hljs-number">0</span>)<br>    &#123;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <br>        &#123;<br>            cin &gt;&gt; w[i];<br>            sum += w[i];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(w, w + n);<br>        <span class="hljs-built_in">reverse</span>(w, w + n);<br>        <br>        length = w[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sum % length == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            &#123;<br>                cout &lt;&lt; length &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            length ++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 166.数独</title>
    <link href="/2022/02/02/AcWing-166-%E6%95%B0%E7%8B%AC/"/>
    <url>/2022/02/02/AcWing-166-%E6%95%B0%E7%8B%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><h2 id="数据表示">数据表示</h2><p>本题中采用单行表示一个问题，考虑采用数组记录每行、每列和每九宫格的数字出现情况。</p><p>题目中选择使用x和y计算得到每个单元格在给出的数组中对应下标。</p><h2 id="剪枝思路">剪枝思路</h2><p>首先本题中每一种情况均唯一，并无冗余。采用的剪枝方法包括</p><ul><li>可行性剪枝</li><li>优先遍历最少方案</li></ul><p>其中可行性剪枝采用了位运算进行优化，通过位运算和lowbit算法可以在o(1)的时间内确定数独中某一行、列和九宫格存在的一个方案。同时通过提前计算每个状态所包含的空格的数量降低了在dfs过程中由于计算空格数量所带来的额外时间开销。</p><h1 id="代码实现">代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">9</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><br><span class="hljs-type">int</span> row[N], col[N], grid[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> ones[M], lg[M]; <span class="hljs-comment">// ones保存每个状态的空格数量，其中1表示空格，lg则是一个2^n的log值预处理</span><br>string puzzle;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> t, <span class="hljs-type">bool</span> is_set)</span> <span class="hljs-comment">// is_set为true的时候为填入数字，否则为还原为空格</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_set) puzzle[x * N + y] = <span class="hljs-string">&#x27;1&#x27;</span> + t;<br>    <span class="hljs-keyword">else</span> puzzle[x * N + y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    <br>    <span class="hljs-type">int</span> v = <span class="hljs-number">1</span> &lt;&lt; t; <span class="hljs-comment">// 此处还是应当注意本题中选择1表示空格，0表示填数</span><br>    <span class="hljs-keyword">if</span> (!is_set) v = -v;<br>    row[x] -= v;<br>    col[y] -= v;<br>    grid[x / <span class="hljs-number">3</span>][y / <span class="hljs-number">3</span>] -= v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化使得全图均为空格</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) row[i] = col[i] = (<span class="hljs-number">1</span> &lt;&lt; N) - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j)<br>        &#123;<br>            grid[i][j] = (<span class="hljs-number">1</span> &lt;&lt; N) - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> row[x] &amp; col[y] &amp; grid[x / <span class="hljs-number">3</span>][y / <span class="hljs-number">3</span>]; <span class="hljs-comment">// 对行、列和九宫格的可行情况进行一个按为与，得到所有可行的方案</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-type">int</span> minv = <span class="hljs-number">10</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            <span class="hljs-keyword">if</span> (puzzle[i * N + j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> state = <span class="hljs-built_in">get</span>(i, j);<br>                <br>                <span class="hljs-keyword">if</span> (ones[state] &lt; maxv)<br>                &#123;<br>                    x = i, y = j;<br>                    minv = ones[state];<br>                &#125; <span class="hljs-comment">//找到可选方案最少的一个位置，剪枝的其中一部分</span><br>            &#125;<br>            <br>    <span class="hljs-type">int</span> state = <span class="hljs-built_in">get</span>(x, y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = state; i != <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i))<br>    &#123;<br>        <span class="hljs-type">int</span> t = lg[<span class="hljs-built_in">lowbit</span>(i)];<br>        <span class="hljs-built_in">draw</span>(x, y, t, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(cnt - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">draw</span>(x, y, t, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) lg[<span class="hljs-number">1</span> &lt;&lt; i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; N; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>        &#123;<br>            ones[i] += (i &gt;&gt; j) &amp; <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-comment">// 状态预处理，ones记录每个状态包含1的数量</span><br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; puzzle)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (puzzle == <span class="hljs-string">&quot;end&quot;</span>) <span class="hljs-keyword">break</span>;<br>        <br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (puzzle[i * N + j] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> v = puzzle[i * N + j] - <span class="hljs-string">&#x27;1&#x27;</span>;<br>                    <span class="hljs-built_in">draw</span>(i, j, v, <span class="hljs-literal">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    cnt ++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">dfs</span>(cnt);<br>        cout &lt;&lt; puzzle &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 167.小猫爬山</title>
    <link href="/2022/01/29/AcWing-167-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1/"/>
    <url>/2022/01/29/AcWing-167-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>考虑到本算法的时间复杂度，如果遍历全部的情况会导致TLE，故需要进行一定的剪枝。</p><p>所以本题需要进行适当的剪枝，优先搜索状态较少的方案，即从个体质量较大的单位开始搜索。同时对非最优方案进行剪枝，最终可以得到结果</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n, w;<br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> c[N], group[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> g)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (g &gt; res) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 非最优剪枝</span><br>    <span class="hljs-keyword">if</span> (t == n) <br>    &#123;<br>        res = g;    <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (c[t] + group[i] &lt;= w) <span class="hljs-comment">//非可行方案剪枝</span><br>        &#123;<br>            group[i] += c[t];<br>            <span class="hljs-built_in">dfs</span>(t + <span class="hljs-number">1</span>, g);<br>            group[i] -= c[t];<br>        &#125;<br>    &#125;<br>    <br>    group[g] += c[t];<br>    <span class="hljs-built_in">dfs</span>(t + <span class="hljs-number">1</span>, g + <span class="hljs-number">1</span>);<br>    group[g] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    res = <span class="hljs-number">0x3f3f3f3f</span>;<br>    cin &gt;&gt; n &gt;&gt; w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; c[i];<br>    <span class="hljs-built_in">sort</span>(c, c + n);<br>    <span class="hljs-built_in">reverse</span>(c, c + n);<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1118.分成互质组</title>
    <link href="/2022/01/27/AcWing-1118-%E5%88%86%E6%88%90%E4%BA%92%E8%B4%A8%E7%BB%84/"/>
    <url>/2022/01/27/AcWing-1118-%E5%88%86%E6%88%90%E4%BA%92%E8%B4%A8%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本算法的基本思路不难，但是必须要注意实现分组的方式不能写错，只需要简单地记录每个组所保存的数字的索引即可得到答案。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">101</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> a[N], group[N][N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> group[], <span class="hljs-type">int</span> gc, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; gc; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">gcd</span>(a[group[j]], a[i]) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> g, <span class="hljs-type">int</span> gc, <span class="hljs-type">int</span> tc, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (g &gt;= res) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (tc == n) res = g;<br>    <span class="hljs-comment">//cout &lt;&lt; tc &lt;&lt; endl;</span><br>    <br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; <span class="hljs-built_in">check</span>(group[g], gc, j))<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            group[g][gc] = j;<br>            <br>            <span class="hljs-built_in">dfs</span>(g, gc + <span class="hljs-number">1</span>, tc + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);<br>            st[j] = <span class="hljs-literal">false</span>;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (flag)<br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(g + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, tc, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];<br>    res = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">//group[0][0] = a[0];</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1117.单词接龙</title>
    <link href="/2022/01/27/AcWing-1117-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <url>/2022/01/27/AcWing-1117-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>常规的DFS问题，只需要注意如何实现字符串匹配的问题即可</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><br>string s[N];<br><span class="hljs-type">int</span> cnt[N];<br><span class="hljs-type">int</span> res;<br><span class="hljs-type">char</span> start;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string last, <span class="hljs-type">int</span> l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//cout &lt;&lt; last &lt;&lt; endl;</span><br>    res = <span class="hljs-built_in">max</span>(l, res);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cnt[i] &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt; last.<span class="hljs-built_in">size</span>() &amp;&amp; len &lt; s[i].<span class="hljs-built_in">size</span>(); ++len)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (last.<span class="hljs-built_in">substr</span>(last.<span class="hljs-built_in">size</span>() - len) == s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len))<br>            &#123;<br>                string temp = last + s[i].<span class="hljs-built_in">substr</span>(len);<br>                cnt[i] ++;<br>                <span class="hljs-comment">//cout &lt;&lt; s[i] &lt;&lt; endl &lt;&lt; endl;</span><br>                <span class="hljs-built_in">dfs</span>(temp, l + s[i].<span class="hljs-built_in">size</span>() - len);<br>                cnt[i] --;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; s[i];<br>    cin &gt;&gt; start;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i][<span class="hljs-number">0</span>] == start) <br>        &#123;<br>            cnt[i] ++;<br>            <span class="hljs-built_in">dfs</span>(s[i], s[i].<span class="hljs-built_in">size</span>());<br>            cnt[i] --;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1116.马走日</title>
    <link href="/2022/01/27/AcWing-1116-%E9%A9%AC%E8%B5%B0%E6%97%A5/"/>
    <url>/2022/01/27/AcWing-1116-%E9%A9%AC%E8%B5%B0%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>简单粗暴的一个DFS</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">11</span>;<br><br><span class="hljs-type">int</span> st[N][N];<br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, PII p, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt == n * m)<br>    &#123;<br>        res ++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    st[p.x][p.y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> x = p.x + dx[i], y = p.y + dy[i];<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= m || st[x][y]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(n, m, &#123;x, y&#125;, cnt + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    st[p.x][p.y] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k, n, m;<br>    PII start;<br>    <br>    cin &gt;&gt; k;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        res = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; start.x &gt;&gt; start.y;<br>        <span class="hljs-built_in">dfs</span>(n, m, start, <span class="hljs-number">1</span>);<br>        cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1113.红与黑</title>
    <link href="/2022/01/27/AcWing-1113-%E7%BA%A2%E4%B8%8E%E9%BB%91/"/>
    <url>/2022/01/27/AcWing-1113-%E7%BA%A2%E4%B8%8E%E9%BB%91/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>常规的洪泛算法解决的问题，只需要从当前点开始扩展，对所有可以访问到的点进行计数即可</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII start;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br>        cnt ++;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m || g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span> &amp;&amp; m != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>            &#123;<br>                cin &gt;&gt; g[i][j];<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)<br>                &#123;<br>                    start.x = i;<br>                    start.y = j;<br>                    g[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        cin &gt;&gt; m &gt;&gt; n;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>BFS</tag>
      
      <tag>Flood Fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1113.迷宫</title>
    <link href="/2022/01/26/AcWing-1113-%E8%BF%B7%E5%AE%AB/"/>
    <url>/2022/01/26/AcWing-1113-%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>非常常规的一个BFS问题，只需要在搜索到终点的时候进行跳出即可，若最终未搜索到终点则返回无法到达。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> k, n;<br>PII start, <span class="hljs-keyword">final</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span> (g[t.x][t.y] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">final</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= n) <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; k;<br>    <span class="hljs-keyword">while</span>(k --)<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            &#123;<br>                cin &gt;&gt; g[i][j];<br>            &#125;<br>        &#125;<br>        <br>        cin &gt;&gt; start.x &gt;&gt; start.y &gt;&gt; <span class="hljs-keyword">final</span>.x &gt;&gt; <span class="hljs-keyword">final</span>.y;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bfs</span>()) cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 178.第K短路</title>
    <link href="/2022/01/26/AcWing-178-%E7%AC%ACK%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/01/26/AcWing-178-%E7%AC%ACK%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题利用了A*的一个性质，即当终点第N次弹出的时候得到的就是第N小的值，其余与常规A*解法一致。</p><h1 id="代码实现">代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIII pair<span class="hljs-string">&lt;int, pair&lt;int, int&gt;</span>&gt;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = <span class="hljs-number">20010</span>;<br><br><span class="hljs-type">int</span> h[N], rh[N], e[M], ne[M], w[M], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m, S, K, T, idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> h[N], <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, T&#125;);<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    dist[T] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> num = t.second, distance = t.first;<br>        <span class="hljs-keyword">if</span> (st[num]) <span class="hljs-keyword">continue</span>;<br>        st[num] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rh[num]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">astar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;dist[S], &#123;<span class="hljs-number">0</span>, S&#125;&#125;);<br>    <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>] == dist[S]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> n = t.second.second, distance = t.second.first;<br>        <span class="hljs-keyword">if</span> (n == T) cnt++;<br>        <span class="hljs-keyword">if</span> (cnt == K) <span class="hljs-keyword">return</span> distance;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[n]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            heap.<span class="hljs-built_in">push</span>(&#123;distance + w[i] + dist[j], &#123;distance + w[i], j&#125;&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">memset</span>(rh, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> rh);<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(h, a, b, c);<br>        <span class="hljs-built_in">add</span>(rh, b, a, c);<br>    &#125;<br>    <br>    cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;<br>    <span class="hljs-keyword">if</span> (S == T) K++;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">astar</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>A*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 179.八数码</title>
    <link href="/2022/01/26/AcWing-179-%E5%85%AB%E6%95%B0%E7%A0%81/"/>
    <url>/2022/01/26/AcWing-179-%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本算法实际上也是BFS的一种应用，但是朴素的BFS搜索会导致需要搜索的状态过多从而发生TLE或者MLE。为了解决这种问题故采用了A*算法</p><h2 id="估计函数">估计函数</h2><p>A*算法中一个关键的部分便是估计函数。通过估计函数使得算法可以找到一个接近理想情况的最佳路径。通常情况下一个可用的估计函数必须满足估计值小于最小值，本题的估计函数选择了各个点到其最终位置的曼哈顿距离之和。</p><p>A*算法使用一个小根堆代替了BFS中的队列，每次从小根堆中取出一个期望距离最短的点进行扩展，其中期望距离=当前点距离起点的距离+当前点到终点的<strong>估计距离</strong>。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIS pair<span class="hljs-string">&lt;int, string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">has_no_result</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;x&#x27;</span> || s[j] == <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            sum += (s[i] &gt; s[j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum &amp; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> num = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> x = i % <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> y = i / <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> acx = (num - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> acy = (num - <span class="hljs-number">1</span>) / <span class="hljs-number">3</span>;<br>        sum += (<span class="hljs-built_in">abs</span>(x - acx) + <span class="hljs-built_in">abs</span>(y - acy));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; dist;<br>    unordered_map&lt;string, pair&lt;<span class="hljs-type">char</span>, string&gt;&gt; prev;<br>    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt;&gt; heap;<br>    <br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">f</span>(s), s&#125;);<br>    dist[s] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> op[] = &#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;;<br>    string <span class="hljs-keyword">final</span> = <span class="hljs-string">&quot;12345678x&quot;</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        string state = t.second;<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-keyword">final</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> d = t.first;<br>        <br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; state.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (state[i] == <span class="hljs-string">&#x27;x&#x27;</span>)<br>            &#123;<br>                x = i % <span class="hljs-number">3</span>;<br>                y = i / <span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-comment">// compute position</span><br>        <br>        string dummy = state;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> nx = x + dx[i], ny = y + dy[i];<br>            <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= <span class="hljs-number">3</span> || ny &lt; <span class="hljs-number">0</span> || ny &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">swap</span>(dummy[y * <span class="hljs-number">3</span> + x], dummy[ny * <span class="hljs-number">3</span> + nx]);<br>            <span class="hljs-keyword">if</span> (!dist.<span class="hljs-built_in">count</span>(dummy) || dist[dummy] &gt; dist[state] + <span class="hljs-number">1</span>)<br>            &#123;<br>                dist[dummy] = dist[state] + <span class="hljs-number">1</span>;<br>                heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">f</span>(dummy) + dist[dummy], dummy&#125;);<br>                prev[dummy] = &#123;op[i], state&#125;;<br>            &#125;<br>            <br>            dummy = state;<br>        &#125;<br>    &#125;<br>    <br>    string res;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">final</span> != s)<br>    &#123;<br>        res += prev[<span class="hljs-keyword">final</span>].first;<br>        <span class="hljs-keyword">final</span> = prev[<span class="hljs-keyword">final</span>].second;<br>    &#125;<br>    <br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">char</span> t;<br>        cin &gt;&gt; t;<br>        s += t;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_no_result</span>(s))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;unsolvable&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">bfs</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>A*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 175.电路维修</title>
    <link href="/2022/01/25/AcWing-175-%E7%94%B5%E8%B7%AF%E7%BB%B4%E4%BF%AE/"/>
    <url>/2022/01/25/AcWing-175-%E7%94%B5%E8%B7%AF%E7%BB%B4%E4%BF%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本算法实际上也是宽搜的一种应用形式。</p><p>题目中我们希望通过旋转某几个电路使得整个电路联通，由于所有的电路均为对角线，故我们可以知道如果希望电路联通，终点座标和和起点座标和的奇偶性相同。故由此我们可以直接判断得出无解的情况。</p><p>而当有解的情况下，我们可以将<strong>电路被旋转</strong>视作边权1、<strong>电路未被旋转</strong>视作边权0，题目将会被转化为一个最短路问题。基于该最短路问题我们可以写出下面代码中的BFS逻辑，即每次扩展从一个点出发向其可能可以到达的四个点进行扩展，对应会有四种不同的边，扩展所使用的边如果和题目中所给出的边不同则为<strong>被旋转</strong>，设置为边权1，否则为0。</p><p>由此和常规的BFS不同的一点在于，该BFS所扩展的边权可能不同，所以我们可以考虑采用<strong>双端队列</strong>，即扩展边权为0的放在队列前端，扩展边权为1的放在边权后端。由于每次从队列中选择的均为队列中距离最短的边，且队列中必然只存在<span class="math inline">\(x\)</span>和<span class="math inline">\(x+1\)</span>两种不同距离的点，所以说使用双端队列同样满足BFS的要求。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> t, n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> dist[N][N];<br><br><span class="hljs-type">char</span> way[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;\\/\\/&quot;</span>;<br><span class="hljs-type">int</span> iy[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, ix[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, dy[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    q.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-comment">//cout &lt;&lt; t.x &lt;&lt; &#x27; &#x27; &lt;&lt; t.y &lt;&lt; &#x27;\n&#x27;;</span><br>        <span class="hljs-keyword">if</span> (t.x == n &amp;&amp; t.y == m) <span class="hljs-keyword">return</span> dist[t.x][t.y];<br>        <br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; n || y &gt; m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> gx = t.x + ix[i], gy = t.y + iy[i];<br>            <span class="hljs-type">int</span> w = (g[gx][gy] != way[i]);<br>            <span class="hljs-type">int</span> d = dist[t.x][t.y] + w;<br>            <span class="hljs-comment">//cout &lt;&lt; d &lt;&lt; &#x27; &#x27; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (d &lt;= dist[x][y])<br>            &#123;<br>                dist[x][y] = d;<br>                <span class="hljs-keyword">if</span> (!w) q.<span class="hljs-built_in">push_front</span>(&#123;x, y&#125;);<br>                <span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t --)<br>    &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        string temp;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            cin &gt;&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) g[i][j] = temp[j];<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> ((n + m) % <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;NO SOLUTION\n&quot;</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>双端队列</tag>
      
      <tag>TODO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1107.魔板</title>
    <link href="/2022/01/24/AcWing-1107-%E9%AD%94%E6%9D%BF/"/>
    <url>/2022/01/24/AcWing-1107-%E9%AD%94%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题实际上依然是BFS的一种扩展方式。题目中要求从初始状态转换到一个特定的目标状态，同时转换操作固定，故可以考虑采用BFS进行搜索，搜索得到的必然是最少操作的方式。</p><p>同时本题要求记录操作序列，故可以参考<em>1076.迷宫问题</em>中记录前驱操作的思想记录每一个操作，最终通过迭代得到操作序列。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; dist;<br>unordered_map&lt;string, pair&lt;<span class="hljs-type">char</span>, string&gt;&gt; pre; <span class="hljs-comment">// &lt;Current, &lt;Operation, LastState&gt;&gt;</span><br>queue&lt;string&gt; q;<br>string target, start=<span class="hljs-string">&quot;12345678&quot;</span>;<br><br><br><span class="hljs-function">string <span class="hljs-title">move0</span><span class="hljs-params">(string a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">move1</span><span class="hljs-params">(string a)</span></span><br><span class="hljs-function"></span>&#123;<br>    string temp;<br>    temp += a[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        temp += a[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>    &#123;<br>        temp += a[i];<br>    &#125;<br>    <br>    temp += a[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">move2</span><span class="hljs-params">(string a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> t1 = a[<span class="hljs-number">1</span>], t2 = a[<span class="hljs-number">2</span>], t3 = a[<span class="hljs-number">5</span>], t4 = a[<span class="hljs-number">6</span>];<br>    a[<span class="hljs-number">1</span>] = t4;<br>    a[<span class="hljs-number">2</span>] = t1;<br>    a[<span class="hljs-number">5</span>] = t2;<br>    a[<span class="hljs-number">6</span>] = t3;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string start, string target)</span></span><br><span class="hljs-function"></span>&#123;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    dist[start] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        string m[<span class="hljs-number">3</span>];<br>        m[<span class="hljs-number">0</span>] = <span class="hljs-built_in">move0</span>(t);<br>        m[<span class="hljs-number">1</span>] = <span class="hljs-built_in">move1</span>(t);<br>        m[<span class="hljs-number">2</span>] = <span class="hljs-built_in">move2</span>(t); <span class="hljs-comment">// generate string by Op.A B C</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dist[m[i]] != <span class="hljs-number">0</span> || m[i] == start) <span class="hljs-keyword">continue</span>;<br>            <br>            dist[m[i]] = dist[t] + <span class="hljs-number">1</span>;<br>            pre[m[i]] = &#123;<span class="hljs-string">&#x27;A&#x27;</span> + i, t&#125;;<br>            <br>            <span class="hljs-keyword">if</span> (m[i] == target) <span class="hljs-keyword">break</span>;<br>            <br>            q.<span class="hljs-built_in">push</span>(m[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> t;<br>        cin &gt;&gt; t;<br>        target += <span class="hljs-built_in">char</span>(t + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">bfs</span>(start, target);<br>    <br>    cout &lt;&lt; dist[target] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>    string res;<br>    <span class="hljs-keyword">while</span>(target != start)<br>    &#123;<br>        res += pre[target].first;<br>        target = pre[target].second;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>()) cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 173.矩阵距离</title>
    <link href="/2022/01/24/AcWing-173-%E7%9F%A9%E9%98%B5%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/24/AcWing-173-%E7%9F%A9%E9%98%B5%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>该算法实际上是针对BFS的一种扩展写法。我们都知道BFS算法会构造一个搜索树，而如果我们希望从多个起点开始BFS最简单的方式便是使用一个虚拟的BFS起点，并在该起点后面连接所有我们希望作为起点的点即可。表现在代码中则变成了用于BFS的队列在初始化的时候将会加入所有的希望作为起点的点。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], dist[N][N], st[N][N];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>        &#123;<br>            <span class="hljs-type">char</span> t = cin.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-comment">//cout &lt;&lt; t &lt;&lt; &#x27; &#x27;;</span><br>            g[i][j] = t - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (g[i][j]) <br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                dist[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        cin.<span class="hljs-built_in">get</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= m || st[x][y]) <span class="hljs-keyword">continue</span>;<br>            dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[t.x][t.y] + <span class="hljs-number">1</span>);<br>            q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>        &#123;<br>            cout &lt;&lt; dist[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1100.抓住那头牛</title>
    <link href="/2022/01/24/AcWing-1100-%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B/"/>
    <url>/2022/01/24/AcWing-1100-%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>这道题更为简单粗暴，相比188和1076的二维搜索问题，本题将搜索放到了一维层面，实际上更加简单了，具体思路同dijkstra模板</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> dist[N], st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(n);<br>    <br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[n] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (st[t]) <span class="hljs-keyword">continue</span>;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (t - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <br>        &#123;<br>            dist[t - <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dist[t - <span class="hljs-number">1</span>], dist[t] + <span class="hljs-number">1</span>);<br>            q.<span class="hljs-built_in">push</span>(t - <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (t + <span class="hljs-number">1</span> &lt; N)<br>        &#123;<br>            dist[t + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dist[t + <span class="hljs-number">1</span>], dist[t] + <span class="hljs-number">1</span>);<br>            q.<span class="hljs-built_in">push</span>(t + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (t * <span class="hljs-number">2</span> &lt; N)<br>        &#123;<br>            dist[t * <span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(dist[t * <span class="hljs-number">2</span>], dist[t] + <span class="hljs-number">1</span>);<br>            q.<span class="hljs-built_in">push</span>(t * <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dist[k];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 188.武士风度的牛</title>
    <link href="/2022/01/24/AcWing-188-%E6%AD%A6%E5%A3%AB%E9%A3%8E%E5%BA%A6%E7%9A%84%E7%89%9B/"/>
    <url>/2022/01/24/AcWing-188-%E6%AD%A6%E5%A3%AB%E9%A3%8E%E5%BA%A6%E7%9A%84%E7%89%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>还是熟悉的Dijkstra，但是这次的行为模式变成了象棋中🐎的行进方式罢了。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">160</span>;<br><br><span class="hljs-type">int</span> g[N][N], n, m, dist[N][N], st[N][N];<br>PII init, target;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>(init);<br>    <br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br>    <br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <br>    dist[init.x][init.y] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= m || g[x][y]) <span class="hljs-keyword">continue</span>;<br>            dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[t.x][t.y] + <span class="hljs-number">1</span>);<br>            q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>        &#123;<br>            <span class="hljs-type">char</span> t;<br>            cin &gt;&gt; t;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&#x27;*&#x27;</span>) g[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                g[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&#x27;K&#x27;</span>) init = &#123;i, j&#125;;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&#x27;H&#x27;</span>) target = &#123;i, j&#125;;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">bfs</span>();<br>    <br>    cout &lt;&lt; dist[target.x][target.y];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1076.迷宫问题</title>
    <link href="/2022/01/24/AcWing-1076-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/24/AcWing-1076-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题实际上就是Dijkstra算法的一个小扩展，需要加入对于路径记录的支持。故可以考虑开辟一个<code>pre[][]</code>数组保存当前点需要走的下一步，通过迭代得到从起点到终点的路径即可。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = N * N;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII pre[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <br>    queue&lt;PII&gt; q, tq;<br>    PII tep = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-built_in">fill</span>(pre[<span class="hljs-number">0</span>], pre[<span class="hljs-number">0</span>] + n * n, tep);<br>    <br>    q.<span class="hljs-built_in">push</span>(&#123;n - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-comment">//st[n - 1][n - 1] = true;</span><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; t.x &lt;&lt; &#x27; &#x27; &lt;&lt; t.y &lt;&lt; &#x27;\n&#x27;;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= n || g[x][y] || st[x][y]) <span class="hljs-keyword">continue</span>;<br>            pre[x][y] = t;<br>            q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        &#125;<br>        <br>    &#125;<br><br>    <br>    PII end = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span>(end.x != n - <span class="hljs-number">1</span> || end.y != n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, pre[end.x][end.y].x, pre[end.x][end.y].y);<br>        <span class="hljs-type">int</span> x = end.x, y = end.y;<br>        end.x = pre[x][y].x, end.y = pre[x][y].y;<br>    &#125;<br>    <span class="hljs-comment">// for (int i = 0; i &lt; n; ++i)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for (int j = 0; j &lt; n; ++j)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         cout &lt;&lt; &#x27;[&#x27; &lt;&lt; pre[i][j].x &lt;&lt; &#x27;,&#x27; &lt;&lt; pre[i][j].y &lt;&lt; &quot;] &quot;;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; &#x27;\n&#x27;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1106.山峰和山谷</title>
    <link href="/2022/01/19/AcWing-1106-%E5%B1%B1%E5%B3%B0%E5%92%8C%E5%B1%B1%E8%B0%B7/"/>
    <url>/2022/01/19/AcWing-1106-%E5%B1%B1%E5%B3%B0%E5%92%8C%E5%B1%B1%E8%B0%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题实际上只是在1097和1098的基础上增加了少量的额外操作。对于判断山峰山谷的操作只需要在确定连通域的同时确定在该连通域边界是否存在更高或更低的格子再进行判断。</p><h1 id="代码实现">代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> g[N][N], st[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>        &#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-type">int</span> peak = <span class="hljs-number">0</span>, vally = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>        &#123;<br>            <span class="hljs-type">bool</span> has_higher = <span class="hljs-literal">false</span>, has_lower = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!st[i][j])<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st[t.first][t.second]) <span class="hljs-keyword">continue</span>;<br>                st[t.first][t.second] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = t.first - <span class="hljs-number">1</span>; x &lt;= t.first + <span class="hljs-number">1</span>; ++x)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = t.second - <span class="hljs-number">1</span>; y &lt;= t.second + <span class="hljs-number">1</span>; ++y)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">1</span> || x &gt; n || y &gt; n) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (g[x][y] &gt; g[t.first][t.second]) has_higher = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[x][y] &lt; g[t.first][t.second]) has_lower = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (!(has_lower &amp;&amp; has_higher) &amp;&amp; (has_higher || has_lower))<br>            &#123;<br>                <span class="hljs-keyword">if</span> (has_higher) vally ++;<br>                <span class="hljs-keyword">if</span> (has_lower) peak ++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (peak || vally)<br>        cout &lt;&lt; peak &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; vally;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;1 1&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1098.城堡问题</title>
    <link href="/2022/01/19/AcWing-1098-%E5%9F%8E%E5%A0%A1%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/19/AcWing-1098-%E5%9F%8E%E5%A0%A1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题实际上不难，和1097解法相同，唯一需要注意的问题是本题使用多个数字之和表示每个房间的墙的情况。但是根据题意实际上就是用一个四位二进制表示，直接按位判断就可以。</p><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>;<br><br><span class="hljs-type">int</span> g[N][N], v[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> x[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> y[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>        &#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; visited;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, mxar = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>        &#123;<br>            <span class="hljs-type">int</span> arr = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!v[i][j])<br>            &#123;<br>                cnt ++;<br>                visited.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(!visited.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">int</span> ox = visited.<span class="hljs-built_in">front</span>().first, oy = visited.<span class="hljs-built_in">front</span>().second;<br>                visited.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (v[ox][oy]) <span class="hljs-keyword">continue</span>;<br>                v[ox][oy] = <span class="hljs-number">1</span>;<br>                arr ++;<br>                <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">4</span>; ++s)<br>                &#123;<br>                    <span class="hljs-type">int</span> nx = ox + x[s], ny = oy + y[s];<br>                    <span class="hljs-keyword">if</span> (nx &gt; n || ny &gt; m || nx &lt; <span class="hljs-number">1</span> || ny &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (!(g[ox][oy] &gt;&gt; s &amp; <span class="hljs-number">1</span>))<br>                    &#123;<br>                        visited.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                        <span class="hljs-comment">//cout &lt;&lt; nx &lt;&lt; &#x27; &#x27; &lt;&lt; ny &lt;&lt; &#x27;\n&#x27;;</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>            mxar = <span class="hljs-built_in">max</span>(mxar, arr);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; mxar;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1097.池塘计数</title>
    <link href="/2022/01/19/AcWing-1097-%E6%B1%A0%E5%A1%98%E8%AE%A1%E6%95%B0/"/>
    <url>/2022/01/19/AcWing-1097-%E6%B1%A0%E5%A1%98%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目思路">题目思路</h1><p>本题目较为简单，但是题目给出的数据若采用递归进行实现会导致<code>stack overflow</code>，故选择使用迭代算法实现。即采用BFS的思想进行计算，通过一个队列存储当前待访问的点并持续进行入队出队操作最终完成洪泛。</p><h1 id="实现代码">实现代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> x[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> y[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>        &#123;<br>            <span class="hljs-type">char</span> t;<br>            cin &gt;&gt; t;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&#x27;.&#x27;</span>) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; visited;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (g[i][j])<br>            &#123;<br>                visited.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                g[i][j] = <span class="hljs-number">0</span>;<br>                cnt ++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(!visited.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">int</span> ox = visited.<span class="hljs-built_in">front</span>().first, oy = visited.<span class="hljs-built_in">front</span>().second;<br>                visited.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">8</span>; ++s)<br>                &#123;<br>                    <span class="hljs-type">int</span> nx = ox + x[s];<br>                    <span class="hljs-type">int</span> ny = oy + y[s];<br>                    <span class="hljs-keyword">if</span> (g[nx][ny]) visited.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                    g[nx][ny] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 320.能量项链</title>
    <link href="/2022/01/10/AcWing-320-%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE/"/>
    <url>/2022/01/10/AcWing-320-%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>本题是一道经典的区间DP问题。</p><p>对于一串珠子<span class="math inline">\((i_1, j_1), (i_2, j_2)...(i_n, j_n)\)</span>假设对其中任意一个区间进行合并，例如对<span class="math inline">\((i_k, j_k)...(i_s, j_s)\)</span>这一段的所有珠子进行合并，最后一次合并的值（释放的能量）取决于合并的顺序。但是同样可以考虑对合并点进行枚举得到结果。</p><p>考虑当合并区间首尾确定的情况下，该次合并的结果只与其的合并的中心点的值有关，故可以考虑在区间DP的过程中枚举合并点得到结果。</p><p>而考虑到本题每个被合并的珠子具有两个参数，合并的过程可以被视作<span class="math inline">\(i_k, j_k(i_{k+1}), j_{k + 1} \to i_k, j_{k + 1}\)</span>而中间的元素将会被两边共用，问题可以从合并n个带有两个参数的珠子转化为合并n+1个带有一个参数的石子的过程，且被选为分割点的石子将会被两边共用。</p><!---more---><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">220</span>;<br><br><span class="hljs-type">int</span> a[N], dp[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], a[i + n] = a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n + <span class="hljs-number">1</span>; ++len)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r; r = l + len - <span class="hljs-number">1</span>, r &lt;= n &lt;&lt; <span class="hljs-number">1</span>; ++l)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) dp[l][l] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l + <span class="hljs-number">1</span>; k &lt; r; ++k)<br>                &#123;<br>                    dp[l][r] = <span class="hljs-built_in">max</span>(dp[l][r], dp[l][k] + dp[k][r] + a[l] * a[r] * a[k]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; ++l)<br>    &#123;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, dp[l][l + n]);<br>    &#125;<br>    <br>    cout &lt;&lt; maxv;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>区间DP</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 1068. 环形石子合并</title>
    <link href="/2022/01/09/AcWing-1068-%E7%8E%AF%E5%BD%A2%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
    <url>/2022/01/09/AcWing-1068-%E7%8E%AF%E5%BD%A2%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>对于石子合并，对于第<span class="math inline">\(i\)</span>和第<span class="math inline">\(i + 1\)</span>两堆石子进行合并，将会得到得分<span class="math inline">\(a[i] + a[i + 1]\)</span>。</p><p>即可以考虑对于第<span class="math inline">\(1...n\)</span>号石子，最后一次合并的得分必然为所有石子数量的总和，即可以选择一个中间位置<span class="math inline">\(i\)</span>，即第<span class="math inline">\(i\)</span>次合并后的总得分为<span class="math inline">\(sc[1...i] + sc[i + 1...n] + a[1 ... n]\)</span>即为前半段的得分加上后半段的得分再加上当前石子数量的总和。</p><p>针对求和问题，可以考虑直接求区间和，即有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">a[i] += a[i - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>则对于第<span class="math inline">\(i\)</span>到第<span class="math inline">\(j\)</span>的总和为<span class="math inline">\(a[j] - a[i - 1]\)</span>。</p><p>而对于划分问题，可以考虑dp数组的定义，<code>dp[i][j]</code>为第<span class="math inline">\(i\)</span>到第<span class="math inline">\(j\)</span>号石子合并的得分。得到转移方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], d[i][k] + dp[k + <span class="hljs-number">1</span>][j]);<br></code></pre></td></tr></table></figure><p>同时对于区间DP问题，我们需要明确需要从小区间向大区间遍历，即<code>for</code>循环遍历的过程是分别遍历<strong>区间长度</strong>和<strong>区间左端点</strong>，并使用二者计算得到区间右端点。</p><p>另外本题中的数组为一个循环数组，为了实现循环数组中的区间DP，可以考虑将数组重复一遍并限定区间DP的长度控制在<code>n</code>，实现对于环形数组的处理</p><p>#代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">420</span>;<br><br><span class="hljs-type">int</span> n, a[N], dpmx[N][N], dpmn[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], a[i + n] = a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n &lt;&lt; <span class="hljs-number">1</span>; ++i) a[i] += a[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//计算区间和</span><br>    <br>    <span class="hljs-built_in">memset</span>(dpmn, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dpmn);<span class="hljs-comment">//初始化最小值数组</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; ++len)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r; r = l + len - <span class="hljs-number">1</span>, r &lt; n &lt;&lt; <span class="hljs-number">1</span>; ++l)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) dpmx[l][l] = dpmn[l][l] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt; r; ++k)<br>                &#123;<br>                    dpmx[l][r] = <span class="hljs-built_in">max</span>(dpmx[l][r], dpmx[l][k] + dpmx[k + <span class="hljs-number">1</span>][r] + a[r] - a[l - <span class="hljs-number">1</span>]);<br>                    dpmn[l][r] = <span class="hljs-built_in">min</span>(dpmn[l][r], dpmn[l][k] + dpmn[k + <span class="hljs-number">1</span>][r] + a[r] - a[l - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> maxv = <span class="hljs-number">-0x3f3f3f3f</span>;<br>    <span class="hljs-type">int</span> minv = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; ++l)<br>    &#123;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, dpmx[l][l + n - <span class="hljs-number">1</span>]);<br>        minv = <span class="hljs-built_in">min</span>(minv, dpmn[l][l + n - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    cout &lt;&lt; minv &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; maxv;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>区间DP</tag>
      
      <tag>DP</tag>
      
      <tag>区间和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 105. 七夕祭</title>
    <link href="/2022/01/09/AcWing-105-%E4%B8%83%E5%A4%95%E7%A5%AD/"/>
    <url>/2022/01/09/AcWing-105-%E4%B8%83%E5%A4%95%E7%A5%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>考虑到本题的实际操作机制，行内相邻交换不会导致列分布变化、列内交换不会导致行分布变化，根据这点我们可以将本题拆分为分别对行和列做循环交换操作。</p><p>假设一个环形结构<span class="math inline">\([a_1, a_2 ... a_n]\)</span>，需要将其中所有的数字通过相邻数字间的交换变为<span class="math inline">\(a\)</span>，假设从<span class="math inline">\(a_i \to a_{i + 1}\)</span>传递<span class="math inline">\(x_i\)</span>个数字(<span class="math inline">\(x_i\)</span>可正可负，且<span class="math inline">\(a_n\to a_1\)</span>为<span class="math inline">\(x_n\)</span>)则有</p><p><span class="math display">\[a_1 + x_n - x_1 = a \\ a_2 + x_1 - x_2 = a \\ ... \\a_n + x_{n - 1} - x_n = a\]</span></p><p>整理得</p><p><span class="math display">\[x_1 - x_n = a_1 - a \\ x_2 - x_1 = a_2 - a \\ ... \\ x_n - x_{n - 1} = a_n - a\]</span></p><p>由于希望求得最小的操作次数，即题目希望求得最小的<span class="math inline">\(|x_1| + |x_2| + ... +|x_n|\)</span>则有</p><p><span class="math display">\[x_1 = x_1 \\ x_2 = x_1 - (a - a_2) \\ x_3 = x_2 - (a - a_3) = x_1 - (2a - a_2 - a_3) \\ ... \\ x_n = x_{n - 1} - (a - a_n) = ... = x_1 - ((n - 1)a-a_2-a_3 ... -a_n)\]</span></p><p>即最终上面的式子被转化为了<span class="math inline">\(|x_1| + |x_1 - (a-a_2)| ...+|x_1 - [(n - 1)a - a_2 - a_3 ... -a_n]|\)</span>最终变为了货仓选址问题。</p><!---more---><h1 id="代码实现">代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, m, t;<br><span class="hljs-type">int</span> r[N], c[N];<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> avg, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> buf[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cnt; ++i)<br>    &#123;<br>        buf[i] = avg - a[i] + buf[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// buf[1] = a - a_2 buf[2] = 2a - a_2 - a_3 ...</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(buf + <span class="hljs-number">1</span>, buf + cnt + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> mid = (<span class="hljs-number">1</span> + cnt) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i)<br>    &#123;<br>        res += <span class="hljs-built_in">abs</span>(buf[i] - buf[mid]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        r[x] ++;<br>        c[y] ++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> col_res = <span class="hljs-number">0</span>, row_res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> col_avg = <span class="hljs-number">0</span>, row_avg = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (t % m &amp;&amp; t % n) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t % m)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;row &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">compute</span>(r, t / n, n);<br>        <br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t % n)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;column &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">compute</span>(c, t / m, m);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;both &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">compute</span>(r, t / n, n) + <span class="hljs-built_in">compute</span>(c, t / m, m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 100.IncDec序列</title>
    <link href="/2022/01/07/AcWing-100-IncDec%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/07/AcWing-100-IncDec%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思路">算法思路</h1><p>算法基于查分数组的前缀和即是原数组的思想进行。</p><p>对于在原始数组上[m, n]区间每个数字+n，体现在差分数组上即第m个数字+n同时第n+1个数字-n。</p><hr /><p>本题提供的基本操作可以使用差分进行表示，即每次+1或-1的操作可以在差分数组上对两端的数字进行操作实现，对于整个差分数组可以用一个折线图进行表示，可以发现当所有的数字经过该操作到达相同值所需步骤最少的过程必然是所有数字达到重叠的区域内。</p><!---more---><h1 id="算法实现">算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> pos = <span class="hljs-number">0</span>, neg = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">1</span>; --i) a[i] -= a[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>) pos += a[i];<br>        <span class="hljs-keyword">else</span> neg -= a[i];<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(pos, neg) + <span class="hljs-built_in">abs</span>(pos - neg) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; <span class="hljs-built_in">abs</span>(pos - neg) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>贪心</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 91.最短Hamilton路径</title>
    <link href="/2022/01/07/AcWing-91-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/07/AcWing-91-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="算法逻辑">算法逻辑</h1><p>本题采用状态压缩DP方式实现。</p><p>定义状态<code>i</code>为一个二进制串，其中1代表已访问的点，0代表未访问的点。DP数组定义为 当前状态*当前正在访问的点。</p><span id="more"></span><h1 id="代码实现">代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">22</span>, M = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> g[N][N], dp[M][N];<br><span class="hljs-type">int</span> m, n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fill</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>] + M * N, <span class="hljs-number">0x3f3f3f3f</span>);<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// initial_data</span><br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            cin &gt;&gt; g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// read graph</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++i) <span class="hljs-comment">// for each status i</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// arrived j</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((i - (<span class="hljs-number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// arrived k but not arrived j</span><br>                    &#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - (<span class="hljs-number">1</span> &lt;&lt; j)][k] + g[j][k]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
      <tag>DP</tag>
      
      <tag>状态压缩DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/06/30/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/06/30/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="算法简介">算法简介</h2><p>KMP算法解决的问题主要在于如何实现在一个较长的字符串中匹配得到一个较短的字符串。</p><p>我们知道对于子串匹配的问题，常用的暴力解法是不断枚举起点，并反复遍历字符串以确定是否匹配，而KMP算法则可以简化这一个过程。该算法可以自动跳过一些可能会导致重复匹配的字符串从而减少匹配的次数。</p><span id="more"></span><h2 id="算法详解">算法详解</h2><p>首先我们假设我们待匹配的字符串是<code>s = abababcafc</code>而子串为<code>p = ababc</code>，整个匹配过程如下所示</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">abababcafc</span><br>ababc<br>   <span class="hljs-regexp"> ^不匹配</span><br><br>abababcafc<br>  ababc<br>      <span class="hljs-regexp"> ^匹配成功</span><br></code></pre></td></tr></table></figure><p>我们可以发现与暴力匹配不同，字符串直接向后移动了两位然后完成了匹配，我们可以观察第二个字符串存在这样的性质</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ab</span>|<span class="hljs-keyword">ab</span>|abcafc<br>^<span class="hljs-number">1</span> ^<span class="hljs-number">2</span><br>   <span class="hljs-keyword">ab</span>|<span class="hljs-keyword">abc</span><br>   ^<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>我们可以发现在这个串中1、2、3三个字符串均相同，实际上这里就是KMP移动字符串的依据，在第一次匹配的过程中我们发现字符串<code>0-1</code>位和<code>2-3</code>位相同，而第一次又成功匹配了<code>0-3</code>位的字符串，所以说实际上下一次进行匹配的时候我们的<code>0-1</code>位可以直接移动到当前<code>2-3</code>位的位置上，然后从<code>2</code>位重新开始匹配，从而减少了匹配的次数。</p><p>而此时我们便会面临一个问题，如何获得上面我们需要的这种相同的关系，此时我们可以考虑定义一个数组<code>next[]</code>，假设<code>next[j]</code>表示以<code>j</code>在<code>p</code>串中以<code>j</code>结尾的满足其<strong>前缀</strong>与<strong>后缀</strong>相同子串中前缀结尾的<strong>索引</strong>，而后续匹配时的跳转操作可以直接使用这个数组完成跳转。接下来我们可以尝试来计算这个数组。</p><h3 id="next数组的计算方法">next数组的计算方法</h3><p>为了推导方便，此时我们假设<code>p=ababdababaa</code>，实际使用的时候我们只需要知道如何从<code>next[0~i - 1]</code>推得<code>next[i]</code>即可</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">//此时我们假设我们已知next<span class="hljs-comment">[8]</span>推导next<span class="hljs-comment">[9]</span>，我们有如下字符串，可以看到next<span class="hljs-comment">[8]</span> = 3<br>|aba|bd|aba|baa<br>//而正因为我们已知了next<span class="hljs-comment">[8]</span> = 3，我们知道p<span class="hljs-comment">[1:3]</span> == p<span class="hljs-comment">[6:8]</span>同时p<span class="hljs-comment">[1:4]</span> != p<span class="hljs-comment">[5:8]</span>，接下来我们继续向后读入一个字符<br>|aba|bd|aba|baa<br>     ^      ^p<span class="hljs-comment">[9]</span><br>     p<span class="hljs-comment">[next<span class="hljs-comment">[9 - 1]</span> + 1]</span><br>//可以发现此时p<span class="hljs-comment">[next<span class="hljs-comment">[9 - 1]</span> + 1]</span> == p<span class="hljs-comment">[9]</span>，故我们可以得到p<span class="hljs-comment">[9]</span> = p<span class="hljs-comment">[8]</span> + 1<br></code></pre></td></tr></table></figure><p>但是我们面临着一个问题，如果第一次匹配不成功应该怎么解决，我们假设下面一种情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">|abab|d|abab|aa<br> <span class="hljs-number">1234</span> <span class="hljs-number">5</span> <span class="hljs-number">6789</span> <span class="hljs-number">01</span><br><span class="hljs-regexp">//</span>此时我们需要计算<span class="hljs-keyword">next</span>[<span class="hljs-number">10</span>]，但是很不幸p[<span class="hljs-keyword">next</span>[<span class="hljs-number">10</span> - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] != p[<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>为了求解得到<code>next[10]</code>，我们只能退而求其次，去尝试更短的子串看看是否可以求解。根据<code>next[9]=4</code>我们可以知道<code>p[1:4] == p[6:9]</code>，而我们又可以发现<code>next[next[9]] = next[4] = 2</code>，即<code>p[1:2] == p[3:4]</code>，而根据<code>next[9]</code>的定义我们又知道<code>p[3:4] == p[8:9]</code>，同时<code>p[next[next[9]] + 1] == p[10]</code>，所以我们可以得到<code>p[1:3] == p[8:10]</code>即<code>next[10] = 3</code>。</p><p>而上面的推导存在一个边界，即当<code>next[next[....]] = 0</code>时，此时不再指望<code>next[0~n-1]</code>会对<code>next[n]</code>做出任何贡献。</p><h3 id="next数组构造代码实现">next数组构造代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; ++i) <span class="hljs-comment">// 假设字符串长度为m，且下标起点为1</span><br>&#123;<br><span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = next[j]; <span class="hljs-comment">// 当出现退无可退（即j回到了0的位置）或匹配成功的时候跳出循环</span><br>  <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++; <span class="hljs-comment">// 对应了匹配成功的情况</span><br>  next[i] = j; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匹配过程">匹配过程</h3><p>既然此时我们获得了<code>next[]</code>，我们便可以开始尝试进行匹配<code>s</code>和<code>p</code>了，匹配过程与<code>next[]</code>构造的过程类似，即在出现第一个无法匹配即<code>s[i] != p[j]</code>或者匹配完全时，将会尝试最大程度的向前移动，这里我们还是继续假设待匹配的字符串是<code>s = ababababfab</code>而子串为<code>p = ababf</code>，匹配的过程可以像这样进行</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ababababfab</span><br>ababf<br>   <span class="hljs-regexp"> ^出现不匹配</span><br></code></pre></td></tr></table></figure><p>此时我们要开始找最长的可以移动的距离，我们可以发现<code>s[5] == p[3]</code>，而同时存在<code>p[1:2] == p[3:4]</code>，故此时我们可以作如下的移动</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ababababfab</span><br>  ababf<br>    <span class="hljs-regexp"> ^下一个判断是否匹配的字符</span><br></code></pre></td></tr></table></figure><p>可以看到这样我们就成功实现了利用<code>next[]</code>一次性移动多位的操作。这里的思想与求<code>next[]</code>的过程类似，即我们实际上是在<code>s</code>上搜索一个与当前已知前缀相互匹配的后缀，假设存在任何一个可以相互匹配的前后缀即可直接将字符串开头移动到求得的后缀的开头的位置。</p><h3 id="匹配过程代码实现">匹配过程代码实现</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>&#123;<br><span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = <span class="hljs-keyword">next</span>[j]; <span class="hljs-regexp">//</span> 在s上匹配一个p的后缀，而由于最终求得的前后缀是前面<span class="hljs-keyword">next</span>数组得到的前后缀，故可以直接获得前文中三个子串相互的关系。<br><span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++; <span class="hljs-regexp">//</span> 若当前位置匹配成功则后移待匹配的指针<br><span class="hljs-keyword">if</span> (j == m) <span class="hljs-regexp">//</span> j到达了p的末尾<br>&#123;<br><span class="hljs-regexp">//</span> 匹配成功<br>j = ne[j]; <span class="hljs-regexp">//</span> 继续后移<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kmp算法的应用">KMP算法的应用</h2><h3 id="状态机kmpacwing-1052.-设计密码">状态机+KMP(AcWing 1052. 设计密码)</h3><p>该题目中实际上可以将我们需要求得的密码视作<code>n</code>次状态转换，其中第一个状态即<code>state[0]</code>就是不存在任何匹配的状态，而由于我们的要求是不能匹配子串，假设子串长度为<code>m</code>，故我们要求不能到达<code>state[m]</code>。</p><p>由于密码的每一位都存在26种情况（题目中密码组成是全小写字母），故对于每一个状态均存在26种转移方式。而我们又知道对于KMP算法实际上每次在计算匹配情况的时候其都只会关心待匹配串<code>s</code>的一个字母，根据这种性质我们可以利用KMP的匹配方式求得每种状态最远可以匹配的子串长度，只要求得的长度没有到达<code>n</code>那就是一种可用的密码。</p><p>首先我们同样可以计算出KMP所需的<code>next[]</code>，然后可以进行状态转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) <span class="hljs-comment">// 这里我们假设不能被包含的子串长度为m</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;a&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++k)<br>&#123;<br><span class="hljs-type">int</span> u = j; <span class="hljs-comment">// 这里的u即为我们当前k可以匹配到的最长子串长度，也就是说如果直接得到k == p[j + 1]时将会直接得到最大匹配长度</span><br><span class="hljs-keyword">while</span>(u &amp;&amp; k != p[u + <span class="hljs-number">1</span>]) u = next[u];<br><span class="hljs-keyword">if</span> (k == p[u + <span class="hljs-number">1</span>]) u++;<br><span class="hljs-keyword">if</span> (u &lt; m) f[i + <span class="hljs-number">1</span>][u] = (f[i + <span class="hljs-number">1</span>][u] + f[i + <span class="hljs-number">1</span>][j]) % MOD;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 3580.整数配对</title>
    <link href="/2021/05/27/AcWing-3580-%E6%95%B4%E6%95%B0%E9%85%8D%E5%AF%B9/"/>
    <url>/2021/05/27/AcWing-3580-%E6%95%B4%E6%95%B0%E9%85%8D%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目详情">题目详情</h2><p>给定 <span class="math inline">\(n\)</span> 个整数 <span class="math inline">\(a_1,a_2,…,a_n\)</span>, <span class="math inline">\(n\)</span> 为偶数。</p><p>现在要将它们两两配对，组成 <span class="math inline">\(n2\)</span> 个数对。</p><p><span class="math inline">\(ai\)</span> 和 <span class="math inline">\(a_j\)</span> 能够配对，当且仅当 <span class="math inline">\(a_i=a_j\)</span>。</p><p>每次增加操作可以使其中的任意一个数 <span class="math inline">\(a_i\)</span> 加一。</p><p>请问，要使得 <span class="math inline">\(n\)</span> 个整数能够成功组成 <span class="math inline">\(\frac{n}{2}\)</span> 个数对，至少要进行多少次增加操作。</p><span id="more"></span><h3 id="输入格式">输入格式</h3><p>第一行包含整数 <span class="math inline">\(n\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数 <span class="math inline">\(a_1,a_2,…,a_n\)</span>。</p><h3 id="输出格式">输出格式</h3><p>一个整数，表示所需最少操作次数</p><h3 id="数据范围">数据范围</h3><p><span class="math display">\[1\leq n\leq10^5\]</span>, <span class="math inline">\(1\leq a_i\leq10^4\)</span></p><h3 id="输入样例1">输入样例1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">10</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">14</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="输出样例1">输出样例1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h3 id="输入样例2">输入样例2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="输出样例2">输出样例2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">99<br></code></pre></td></tr></table></figure><h2 id="题目思路">题目思路</h2><p>本题中考虑到需要使用最小的修改可以实现所有的整数配对，故实际上最优解一定是将某个数字<code>a[i]</code>修改为离他最近的一个数字<code>a[j]</code>。</p><p>我们可以将排序好的所有数字放到一个数轴上，就可以看到下面的情况</p><figure><img src="https://i.loli.net/2021/05/27/a83RVLOoG4hKdYM.png" alt="" /><figcaption>image.png</figcaption></figure><p>为了使得我们的修改量最少，即数轴上每个点找到和他配对的一个点所需移动的总距离最小，此时我们需要尽量少地越过其他的点，故可以证明对于每个<code>a[i]</code>都必须找其相邻的点进行配对。</p><p>假设我们使用蓝色的方法进行配对，此时<code>a[1]</code>必须越过<code>a[2]</code>和<code>a[3]</code>寻找与其配对的点，此时并非最小。</p><figure><img src="/Users/cydia2001/Library/Application%20Support/typora-user-images/image-20210527191959278.png" alt="" /><figcaption>image-20210527191959278</figcaption></figure><p>同样对于后面的每一个点均适用于该种情况。</p><h2 id="代码实现">代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        res += <span class="hljs-built_in">abs</span>(a[i + <span class="hljs-number">1</span>] - a[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多重背包系列问题</title>
    <link href="/2021/05/23/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2021/05/23/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题简介">问题简介</h2><p>多重背包问题相对于完全背包问题最大的区别在于多重背包问题中每个物品的数量是有限的，但是二者的状态转移方程相同，故其可以由完全背包问题改写而来。</p><p>但是直接改写而来的朴素版本的完全背包问题本身无法应对较大的数据范围，故需要适当进行优化，本文便是针对该类常规的多重背包问题进行解答。</p><span id="more"></span><h2 id="acwing-5.多重背包问题ii">AcWing 5.多重背包问题II</h2><p>当数据范围较小的时候可以考虑进行<strong>二进制优化</strong>，即将一组n个物品拆分为1个、2个、4个...，将问题转化为了01背包问题，即可以解决。</p><p>该问题的基本原理在于2的k次方可以表达出<span class="math inline">\(0\)</span>到<span class="math inline">\(2^k - 1\)</span>范围内的所有数字，故可以得到该种划分方式。</p><h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><br><span class="hljs-type">int</span> n, V, idx;<br><span class="hljs-type">int</span> cnt[N], w[N], v[N], f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; V;<br>    <span class="hljs-keyword">while</span>(n --)<br>    &#123;<br>        <span class="hljs-type">int</span> tc, tw, tv;<br>        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; tc;<br>        <br>        <span class="hljs-type">int</span> amt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(amt &lt;= tc)<br>        &#123;<br>            tc -= amt;<br>            w[idx] = tw * amt;<br>            v[idx] = tv * amt;<br>            amt &lt;&lt;= <span class="hljs-number">1</span>;<br>            idx ++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (tc != <span class="hljs-number">0</span>) <br>        &#123;<br>            w[idx] = tw * tc;<br>            v[idx] = tv * tc;<br>            idx ++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= v[i]; --j)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; f[V];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="acwing-6.多重背包问题3">AcWing 6.多重背包问题3</h2><p>该问题中数据规模进一步扩大，原始的方法已经无法满足需求，故此时我们可以尝试去寻找规律去分析该问题。</p><p>首先我们可以将各个状态列出进行观察，有</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">f[i, <span class="hljs-keyword">j] </span>= max(f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j], </span>f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- v] + w, f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- <span class="hljs-number">2</span>v] + <span class="hljs-number">2</span>w ... f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- sv] + <span class="hljs-keyword">sw)</span><br><span class="hljs-keyword"></span>f[i, <span class="hljs-keyword">j </span>- v] = max(             f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- v],     f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- <span class="hljs-number">2</span>v] + w ...  f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- sv] + (s - <span class="hljs-number">1</span>)w + f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- (s + <span class="hljs-number">1</span>)v] + <span class="hljs-keyword">sw)</span><br><span class="hljs-keyword"></span>...<br></code></pre></td></tr></table></figure><p>可以看到我们假设将物品全部选中后依旧不会超出容量的最大限制，此时<code>f[i, j]</code>与<code>f[i, j - v]</code>并不能如同完全背包问题那样对齐，故我们需要考虑其他的方法来解决这个问题。</p><p>当然，当我们列出剩下的每一项后我们可以发现一个规律，即该问题实际上是一个滑动窗口求最大值问题，即按照上面的对齐方式可以看出实际上<code>f[i, j]</code>除去第一项之后剩余项实际上可以看作是<code>f[i, j - v]</code>对应的窗口向固定方向滑动了一步。故根据这个特性我们便可以完成该题。可以考虑将上面的<code>-</code>更换为<code>+</code>，即从小到大递增。</p><p>但是此时我们还需要解决关于单调队列中偏移量的问题，在原始的式子中我们可以看到所有项后面都带着一个偏移量，而在单调队列转换的过程中就会出现单调队列最前方的项每次都需要+w的情况，如下所示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span>)<br>f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j + v]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> + w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j + v]</span>)<br>f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j + 2v]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> + <span class="hljs-number">2</span>w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j + v]</span> + w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j + 2v]</span>)<br>...<br></code></pre></td></tr></table></figure><p>故可以考虑转换为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">f[i, <span class="hljs-keyword">j] </span>= max(f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j] </span>- <span class="hljs-keyword">sw, </span>s[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- v] - (s - <span class="hljs-number">1</span>)w, ..., f[i - <span class="hljs-number">1</span>, <span class="hljs-keyword">j </span>- sv]) + <span class="hljs-keyword">sw</span><br></code></pre></td></tr></table></figure><p>即此时我们的单调队列可以转换为针对转换后<code>max()</code>函数内的各项求单调队列，然后将总体的偏移量加回。</p><p>实际上最后我们的式子就被转换成了这样</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">f[i][j]      = max(f[i - <span class="hljs-number">1</span>][j])<br>f[i][j + v]  = max(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j + v] - w) + w<br>f[i][j + <span class="hljs-number">2</span>v] = max(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j + v] - w, f[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>v] - <span class="hljs-number">2</span>w) + <span class="hljs-number">2</span>w;<br>...<br>f[i][j + nv] = max(f[i - <span class="hljs-number">1</span>][j + (n - s)v], f[i - <span class="hljs-number">1</span>][j + (n - s + <span class="hljs-number">1</span>)v] - w, ... f[i - <span class="hljs-number">1</span>][j + nv] - sv) + sv<br></code></pre></td></tr></table></figure><h3 id="代码实现-1">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N], g[N], q[N];<br><span class="hljs-type">int</span> v, w, s;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-built_in">memcpy</span>(g, f, <span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; v; ++j)<br>        &#123;<br>            <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j; k &lt;= m; k += v)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ; <span class="hljs-comment">// 注意这里的k代表了总体积，即当k - s * v大于了队头保存的体积时将会弹出队头</span><br>                <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ; <span class="hljs-comment">// 将队列尾部所有小于当前值的元素统统删除</span><br>                q[ ++ tt] = k;<br>                f[k] = g[q[hh]] + (k - q[hh]) / v * w; <span class="hljs-comment">// 将偏移量加回</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; f[m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 532. 货币系统</title>
    <link href="/2021/05/22/AcWing-532/"/>
    <url>/2021/05/22/AcWing-532/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>在网友的国度中共有<code>n</code>种不同面额的货币，第 <code>i</code> 种货币的面额为<code>a[i]</code>，你可以假设每一种货币都有无穷多张。</p><p>为了方便，我们把货币种数为<code>n</code>、面额数组为<code>a[1..n]</code>的货币系统记作<code>(n,a)</code> 。 </p><p>在一个完善的货币系统中，每一个非负整数的金额 <code>x</code> 都应该可以被表示出，即对每一个非负整数 <code>x</code>，都存在 nn 个非负整数 <code>t[i]</code> 满足 <code>a[i]*t[i]</code> 的和为 <code>x</code>。</p><p>然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 <code>x</code> 不能被该货币系统表示出。</p><p>例如在货币系统 <code>n=3,a=[2,5,9]</code> 中，金额 <code>1,3</code> 就无法被表示出来。 </p><p>两个货币系统 <code>(n,a)</code> 和 <code>(m,b)</code> 是等价的，当且仅当对于任意非负整数 <code>x</code>，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p><p>现在网友们打算简化一下货币系统。</p><p>他们希望找到一个货币系统 <code>(m,b)</code>，满足 <code>(m,b)</code> 与原来的货币系统 <code>(n,a)</code> 等价，且 <code>m</code> 尽可能的小。</p><p>他们希望你来协助完成这个艰巨的任务：找到最小的 <code>m</code>。</p><span id="more"></span><h2 id="输入格式">输入格式</h2><p>输入文件的第一行包含一个整数 <code>T</code>，表示数据的组数。</p><p>接下来按照如下格式分别给出 <code>T</code> 组数据。 </p><p>每组数据的第一行包含一个正整数 <code>n</code>。</p><p>接下来一行包含 <code>n</code> 个由空格隔开的正整数 <code>a[i]</code>。</p><h2 id="输出格式">输出格式</h2><p>输出文件共有 <code>T</code> 行，对于每组数据，输出一行一个正整数，表示所有与 <code>(n,a)</code> 等价的货币系统 <code>(m,b)</code> 中，最小的 <code>m</code>。</p><h2 id="数据范围">数据范围</h2><p><span class="math display">\[1 \leq n \leq 100\]</span></p><p><span class="math display">\[1 \leq a[i]\leq 25000\]</span></p><p><span class="math display">\[1 \leq T \leq 20\]</span></p><h2 id="输入样例">输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><br><span class="hljs-symbol">4 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">19</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <br><span class="hljs-symbol">5 </span><br><span class="hljs-symbol">11 </span><span class="hljs-number">29</span> <span class="hljs-number">13</span> <span class="hljs-number">19</span> <span class="hljs-number">17</span> <br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>5<br></code></pre></td></tr></table></figure><h2 id="题目思路">题目思路</h2><p>本题中的货币系统实际上就是在给定的一串数字中去掉所有的可以被其他任意数字表示出的数字。故可以考虑使用动态规划求出使用该列数字可以表出的所有数字的方案数量，当且仅当给出数字的表示方案数量大于1的时候，即该数字除了可以被自己表出还可以被其他数字组合表出的时候即可以去掉。</p><p>根据以上思路该题将会退化为一个完全背包组合问题，代码实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25010</span>, CNT = <span class="hljs-number">101</span>;<br><br><span class="hljs-type">int</span> T, n;<br><span class="hljs-type">int</span> a[CNT];<span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-built_in">fill</span>(f, f + N, <span class="hljs-number">0</span>);<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>, res = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        &#123;<br>            cin &gt;&gt; a[i]; mx = <span class="hljs-built_in">max</span>(a[i], mx);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a[i]; j &lt;= mx; ++j) f[j] += f[j - a[i]];<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (f[a[i]] &gt; <span class="hljs-number">1</span>) res--;<br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Rust生活：03-控制流与逻辑运算符</title>
    <link href="/2020/11/27/Rust-03/"/>
    <url>/2020/11/27/Rust-03/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>作为一款合格的程序语言，基本的控制语句是必须有的，而对于Rust来说她的控制流语句相对于传统的语言来说都要更为丰富，本文将会大体地介绍Rust的各类控制语句及其的基本用法。</p><span id="more"></span><h1 id="if">if</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs if```语句作为大多数语言的标配，在Rust中自然也没有缺席，对于Rust来说与```if```搭配的同样是```else```，但是不同于经常拿来和Rust对比的C++，Rust的```if```语句后面的条件并不需要括号包裹起来，如果你用括号把它包裹的话编译器将会送给你一个大大的warning，所以说通常Rust中的一个条件语句就像这样">```rust<br>if condition &#123;<br>    // do something<br>&#125;else&#123;<br>    // do something<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="match">match</h1><p>说到了<code>if</code>，自然少不了我们的好朋友<code>switch</code>，不过非常喜闻乐见的是Rust并没有<code>switch</code>，取而代之的是功能强大的<code>match</code>。<code>match</code>作为Rust中著名的条件选择语句，它不止用于多条件的判断控制，它还经常出现于<code>Option</code>的判断等等各类<code>None</code>类型或者错误处理的场景。常见的<code>match</code>的使用场景如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">match</span>(item)&#123;<br>    condition_1 =&gt; <span class="hljs-comment">//do something</span><br>    condition_2 =&gt; &#123;<br>        <span class="hljs-comment">//do something</span><br>    &#125;<br>    _=&gt; <span class="hljs-comment">//do default thing</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以看到Rust的<code>match</code>语句支持单行或者多行的情况，其中多行的情况必须使用大括号包起来，同时<code>match</code>同样有一个<code>_</code>分支，这个分支一般是作为default分支存在。有一点非常重要，所有分支的返回值类型必须相同。</p><p>但是前面又提到了<code>match</code>相对于<code>switch</code>更为强大，所以这里我们将会探讨之所以<code>match</code>强大的原因</p><h2 id="match可以作为表达式">match可以作为表达式</h2><p>在Rust中，match有一个非常常用的用法，在这种情况下所有的分支都必须要有返回值，就像这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">match</span> (item)&#123;<br>    condition_1 =&gt; &#123;<br>        <span class="hljs-number">1</span><br>    &#125;<br>    condition_2 =&gt; &#123;<br>        <span class="hljs-number">1</span> * <span class="hljs-number">2</span><br>    &#125;<br>    _=&gt; &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下各个代码块最终的执行后的返回值将会被赋给<code>s</code></p><h2 id="match的分支条件可以用于解包各类enum">match的分支条件可以用于解包各类enum</h2><p>上面也说到了<code>match</code>可以用于处理<code>Option&lt;T&gt;</code>类型，在Rust中我们可以这样用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-title function_ invoke__">match</span>(s)&#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>    &#125;<br>    <span class="hljs-literal">None</span> =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;is none&quot;</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">// 输出5</span><br><br></code></pre></td></tr></table></figure><p>就像这样，Rust可以利用<code>match</code>语句轻松地解决<code>Option&lt;T&gt;</code>类型的问题。</p><h1 id="后记">后记</h1><p>在写了四篇Rust的博客之后，我突然发现自己对Rust的理解非常的零散肤浅，所以从本篇开始《从零开始的Rust生活》系列将会暂时停更，待到我更加了解Rust后再继续进行更新。接下来本博客将会开始逐步更新本人的Rust学习记录，同步于本人的Rust的学习进程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>程序语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Rust生活：02-函数</title>
    <link href="/2020/11/23/Rust-02/"/>
    <url>/2020/11/23/Rust-02/</url>
    
    <content type="html"><![CDATA[<h1 id="函数是什么">函数是什么</h1><p>相信各位学Rust的读者应该多少接触过至少一门程序语言，不过这里我还是会按照我的理解尽可能的去为函数做一个相对更为简单的定义。</p><p>对于Rust来说，函数的意义与大多数的程序语言都很相似，我们可以将其视作程序中的一个功能模块。这个功能模块可以对一些我们会反复使用的代码进行封装，从而大幅度简化程序的开发过程。</p><span id="more"></span><h1 id="rust的函数长什么样">Rust的函数长什么样</h1><p>Rust中声明一个函数需要用到<code>fn</code>关键字，通常一个函数的样子形如 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>(arg1: T1, arg2: T2) <span class="hljs-punctuation">-&gt;</span> T&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure> 其中<code>func()</code>就是喜闻乐见的函数名，而<code>T</code>则对应的是他的返回类型，括号里面则是函数需要传入的参数，类比到C++可以就像下面这样 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">T <span class="hljs-title">func</span><span class="hljs-params">(T1 arg1, T2 arg2)</span></span>&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure> 对于Rust的函数，他的返回值和参数的参数列表都是可选的，比如下面的代码就声明了一个不需要传入参数的函数 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>() <span class="hljs-punctuation">-&gt;</span> T&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure> 而下面这样则声明了一个没有返回值的函数 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>(arg1:T)&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure> 众所周知的是一个函数如果声明了返回类型后，其就必须有一个返回值。和大多数语言一样，rust可以使用<code>return</code>返回一个值，就像这样 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_one</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 但是对于Rust来说，还有另外一种方式可以用来作为返回值使用，在多数情况下Rust的开发者们也更倾向使用这种方式进行返回，就像下面这样 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">mul</span>(x: <span class="hljs-type">i32</span>, y:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = x * y;<br>    t<br>&#125;<br></code></pre></td></tr></table></figure> 我们可以看到的是函数内的最后一行的<code>t</code>后面并没有<code>;</code>，但是我们又知道Rust每行代码最后必然会有<code>;</code>。而在一个有返回值的函数中，通常这样的写法会出现在整个函数的末尾，他的含义等价于<code>return t;</code>。<br />另外，Rust不止可以返回一个确定的变量，其同样可以将一个表达式作为返回值，就像下面这样 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">mul</span>(x:<span class="hljs-type">i32</span>, y:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    x * y<br>&#125;<br></code></pre></td></tr></table></figure> 这个函数的功能等价于上一个<code>mul()</code>，但是它并没有声明一个中间变量<code>t</code>，而是选择直接返回<code>x*y</code>，这样的行为在Rust中是合法的，它同样可以实现目标功能而不会出现任何不可预期的问题。</p><h1 id="关于闭包">关于闭包</h1><p>Rust中也存在着一个类似于很多语言中所存在的lambda的存在，那就是闭包。<br />闭包本质上是一个匿名的函数，其被广泛应用于Rust的多线程处理中，本节中不会讨论闭包，因为在整个Rust学习的前期闭包基本不会被提到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>程序语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Rust生活：01-基本类型与基本运算符</title>
    <link href="/2020/11/21/Rust-01/"/>
    <url>/2020/11/21/Rust-01/</url>
    
    <content type="html"><![CDATA[<h1 id="rust中的基本数据类型">Rust中的基本数据类型</h1><p>Rust中的基本数据类型和大多数的语言一样，都可以简单的被分为整型、浮点型、布尔型等等，同时Rust还有一些专属于自身的一些很奇妙的类型，包括<code>Option&lt;T&gt;</code>,<code>Box&lt;T&gt;</code>等等。</p><p>通常Rust中的类型对应的符号为：</p><ul><li>有符号整型：<code>isize</code>,<code>i8</code>,<code>i16</code>,<code>i32</code>,<code>i64</code>,<code>i128</code></li><li>无符号整型：<code>usize</code>,<code>u8</code>,<code>u16</code>,<code>u32</code>,<code>u64</code>,<code>u128</code></li><li>浮点型：<code>f32</code>,<code>f64</code></li><li>布尔型：<code>bool</code></li><li>unit类型：<code>()</code></li><li>引用：<code>&amp;T</code>,<code>&amp;mut T</code></li><li>裸指针：<code>*mut T</code>,<code>*const T</code></li><li><code>!</code></li></ul><span id="more"></span><p>这里值得一提的是，Rust中的<code>!</code>类型在多数情况下实际上代表了<strong>不会返回</strong>，他的功能包括在<code>match()</code>块中实现对各种条件返回类型的补全(因为Rust中对于<code>match()</code>块要求每个分支的返回类型必须相同，当某一个分支不会返回而是导致程序异常退出的时候则可以通过返回一个<code>!</code>来通过编译器检查)</p><p>另外对于Rust还有以下几种常用的类型：</p><ul><li><code>Option&lt;T&gt;</code>：Rust用于解决"空"的一个方案，一个<code>Option&lt;T&gt;</code>枚举量可以是一个<code>Option&lt;T&gt;::Some(n)</code>代表非空，也可以是一个<code>Option&lt;T&gt;::None</code>表示空</li><li><code>Box&lt;T&gt;</code>：堆上分配的指针</li><li><code>Rc&lt;T&gt;</code>,<code>Arc&lt;T&gt;</code>：智能指针(可以这么想)</li><li><code>RefCell&lt;T&gt;</code>：更加神奇的指针(之后会讨论的)</li><li>以及很多</li></ul><p>可以说Rust为了保证其基本的安全可以说是费尽了心思，搞出了一大堆用于应对各种情况的类型，某种意义上这也是Rust难学的一个重要原因。</p><h1 id="类型强制转换">类型强制转换</h1><p>类型强制转换可以说是几乎现役的所有程序语言必备的功能，Rust自然也不例外。<br />对于Rust其使用了关键字<code>as</code>用于类型转换。对于Rust来说强制类型转换同样需要各个类型之间是支持强制类型转换的，不然编译器报错警告。同时Rust对于从高类型向低类型转换的时候不会报错，最多一个warning了事，所以也不要指望编译器会帮你解决把一个<code>i32</code>转换到<code>i8</code>导致的溢出问题。</p><h1 id="运算符">运算符</h1><p>作为一款合格的程序语言，Rust自然也具有完备的运算符系统，考虑到运算符的数量实在是太多了(主要是懒)，<a href="https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html">这里</a>是官方的运算符列表，各位可以作为参考资料。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>程序语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Rust生活：00-前言</title>
    <link href="/2020/11/20/Rust-00/"/>
    <url>/2020/11/20/Rust-00/</url>
    
    <content type="html"><![CDATA[<h1 id="关于我为什么要写这个系列的博客">关于我为什么要写这个系列的博客</h1><p>我只是一位Rust初学者，写这篇博客一方面是为了记录自己Rust的学习历程，另外一方面也希望可以为后来学Rust的人指出一条路，虽然我觉得我还不够格被称为领路人，但是我希望终有一天也可以称为像<a href="https://github.com/ZhangHanDong/">张汉东</a>这样的大神，能够吃透Rust这门语言，让Rust的编译器成为自己的朋友而并非敌人，虽然在学习的前期她的确像一个敌人那样阻碍着代码的编译(笑)。总之这个系列的博客将会成为我Rust学习之路的一个记录，也希望它可以给每一个人帮助。</p><span id="more"></span><h1 id="关于我为什么会选择rust">关于我为什么会选择Rust</h1><ol type="1"><li>她是安全的</li><li>她是全新的</li><li>她是社区驱动的</li><li>她是奇妙的</li><li>她会教会你如何写出安全的代码</li></ol><h1 id="关于本系列博客的一些说明">关于本系列博客的一些说明</h1><ol type="1"><li>所有的代码均会在对应博客写作时的Rust Stable版本下成功运行</li><li>我将会完全从一个初学者的角度来看Rust，所以自然也没有那些书籍写的那么全面</li><li>主要的内容将会参考<a href="https://book.douban.com/subject/30312231/">《深入浅出Rust》</a>和<a href="https://book.douban.com/subject/30418895/">《Rust编程之道》</a>，也推荐大家可以去看看</li><li>一切的内容都是兴趣使然的</li><li>欢迎提issue</li></ol><h1 id="关于如何安装rust">关于如何安装Rust</h1><p>出门左转<a href="https://www.rust-lang.org/">Rust官网</a>，右上角切换到中文，相信大家都看得懂的吧(笑)</p><h1 id="关于用什么ide">关于用什么IDE</h1><p>本人目前使用的是CLion配合Rust插件，之前也接触过vscode + rust(rls)插件和vscode + rust-analyzer这两种搭配，具体那种好用我也不好说，但是如果真的想要最完整的IDE体验的话本人更推荐使用CLion+Rust插件的组合，不过基于开源、美观(主要是美观)的原则，我更倾向于vscode + rust-analyzer这种搭配。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>程序语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁与银行家算法</title>
    <link href="/2020/11/19/%E6%AD%BB%E9%94%81%E4%B8%8E%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/19/%E6%AD%BB%E9%94%81%E4%B8%8E%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁">死锁</h1><p>死锁作为多进(线)程开发中经常遇到的问题，其通常体现为多个进程和线程同时处于阻塞状态并且在没有任何外力干扰的情况下完全无法解除这种状态的情况。我们可以通过一个著名的场景来具体地理解死锁的概念。</p><span id="more"></span><h2 id="哲学家用餐问题">哲学家用餐问题</h2><p>哲学家用餐问题主要模型在一个<strong>圆桌</strong>上坐着n位哲学家，而每位哲学家的间隔处均放着一只筷子，所有的哲学家均处拥有进餐和思考两种状态，其中如果希望进入用餐状态则需要同时获得左右两边的筷子。<br />现在假设总共有5个哲学家，对应的就是5只筷子，画成图就如下所示 <img src="https://i.loli.net/2020/11/19/5BZeJAtpYKHfzuS.png" alt="image.png" /> 这张图来自于维基百科<a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a>,故筷子变成了叉子，将就看看吧(笑)</p><h3 id="哲学家用餐问题与死锁">哲学家用餐问题与死锁</h3><p>现在我们要在这个问题中引入死锁的问题，我们假设所有的哲学家同时希望就餐，此时他们同时拿起了他们左侧的筷子(叉子)，由于这群哲学家都是自私自利的，他们在成功就餐之前<strong>不会放弃</strong>手上的筷子(叉子)，故接下来他们在请求自己右边的叉子的时候所有的哲学家都不会获得在他们右手的筷子(叉子)，因为右边的筷子(叉子)均被他们各自右边的哲学家取走了，所以从这个时刻开始所有的哲学家均无法就餐，由于他们都不愿意放弃手上已经获得的筷子(叉子)，所以没有人会打破这个僵局，也就是说现在发生了<strong>死锁</strong></p><h3 id="常规的解决方案">常规的解决方案</h3><p>由于哲学家问题涉及到的请求的资源种类单一，我们可以使用在之前学到的信号量机制轻松地解决这个问题。</p><h4 id="服务生机制">服务生机制</h4><p>第一种方法就是引入一个服务生，当哲学家需要进餐的时候他们将不会自己拿起自己的筷子(叉子)，而是由服务生检查他两侧是否有筷子(叉子)，如果都有的时候便由服务生拿起两侧的餐具交给这位哲学家，这样实现了在请求资源之前对资源进行检查，防止出现死锁的情况。 我们可以用伪代码实现如下，我们将会对哲学家进行编号，顺时针0-4，其中0号哲学家左边的筷子视作0号筷子，右边为1号，依次递增。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">waiter</span>: Semaphore = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">fork</span>: <span class="hljs-type">Vec</span>&lt;Semaphore&gt; = [<span class="hljs-number">1</span>; <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">philosopher</span>(code:<span class="hljs-type">i32</span>)&#123;<br>    waiter.<span class="hljs-title function_ invoke__">wait</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ready</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> fork[left].<span class="hljs-title function_ invoke__">available</span>() and fork[right].<span class="hljs-title function_ invoke__">available</span>()&#123;<br>        fork[left].<span class="hljs-title function_ invoke__">wait</span>();<br>        fork[right].<span class="hljs-title function_ invoke__">wait</span>();<br>    &#125;<br>    waiter.<span class="hljs-title function_ invoke__">signal</span>();<br>    <span class="hljs-keyword">if</span> ready&#123;<br>        <span class="hljs-comment">//进餐</span><br>        fork[left].<span class="hljs-title function_ invoke__">signal</span>();<br>        fork[right].<span class="hljs-title function_ invoke__">signal</span>():<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//左右筷子被占用，无法就餐</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="轮流进餐机制">轮流进餐机制</h4><p>第二种方法便是要求每次只能由一个哲学家要求进餐，也就是说当某个哲学家宣布自己要进餐的时候其他所有人都不能对自己身边的餐具进行请求，只能由要求进餐的这位哲学家拿起自己两侧的餐具进行就餐，就餐完毕之后其他人才能再次宣布自己要就餐。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">house</span>: Semaphore = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">fork</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = [<span class="hljs-number">1</span>; <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">philosopher</span>(code: <span class="hljs-type">i32</span>)&#123;<br>    house.<span class="hljs-title function_ invoke__">wait</span>();<br>    fork[left] = <span class="hljs-number">0</span>;<br>    fork[right] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//就餐</span><br>    fork[left] = <span class="hljs-number">1</span>;<br>    fork[right] = <span class="hljs-number">1</span>;<br>    house.<span class="hljs-title function_ invoke__">signal</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="死锁的概念">死锁的概念</h2><p>从上面的问题，相信读者也对死锁有了一定的概念，对于死锁来说其自身的产生实际上有四个必要条件，而后续探讨的系统性的对死锁的解决同样基于这四个必要条件进行</p><ul><li>互斥条件：多个线程之间请求的资源具有互斥性</li><li>不可剥夺条件：线程请求的资源是不可剥夺的</li><li>持有请求条件：当一个线程持有一个或多个资源的同时其会去请求其他线程所占有的资源，引起阻塞</li><li>循环等待条件：多个线程同时发生持有等待，同时这些线程持有的资源与请求的资源可以形成一个环。</li></ul><h2 id="死锁的解决">死锁的解决</h2><h3 id="预防死锁">预防死锁</h3><p>预防死锁实际上是最低效，最暴力，但是最简单的方法，其通过分别破坏死锁的四种条件完成对死锁的预防。</p><ul><li>互斥条件：其作为系统的基本特征，<strong>无法破坏</strong></li><li>持有请求条件：要求进程在创建时需要申请全部的资源，如果不满足的话直接阻止进程的创建</li><li>不可剥夺条件：要求进程在全部资源全部申请成功后才能执行，否则将进程阻塞</li><li>循环等待条件：按序申请，相当于对所有资源进行编号，进程在申请资源的时候必须严格按照序号进行申请</li></ul><h3 id="避免死锁">避免死锁</h3><p>避免死锁相对于预防死锁来说性能更好，其的基本流程为判断申请资源的时候是否有死锁风险，如果没有的话则授予资源，否则阻塞进程直到资源可用。</p><h4 id="安全与不安全的划分">安全与不安全的划分</h4><p>当系统按照一定的顺序调度进程，如<span class="math inline">\(P_1, P_2, P_3...P_n\)</span>，对于其中任何一个进程<span class="math inline">\(P_i\)</span>均应当满足其所请求资源的最大需求，此时则视为安全，否则视为不安全。<br />此时，我们就需要构建一个算法用来计算得到这样一个进程序列。同时由于系统中的进程实际上是不断地在申请和释放资源的，故实际上系统的安全和不安全其实是在反复切换的。</p><h4 id="银行家算法">银行家算法</h4><p>银行家算法便是一种著名的用于实现避免死锁的算法。</p><h5 id="数据结构">数据结构</h5><ul><li>可用的资源量：<code>Available</code>，长度为n的向量</li><li>最大需求矩阵：<code>Max</code>，n行m列的矩阵</li><li>分配矩阵：<code>Allocation</code>，n行m列的矩阵</li><li>需求矩阵：<code>Need</code>，n行m列的矩阵</li><li>资源请求向量：<code>Request</code>，长度为m的向量，且<code>Request_i[j]</code>表示i进程对j资源的需求量</li></ul><p>其中<code>Max = Allocation + Need</code></p><h5 id="算法过程">算法过程</h5><p>当进程i提出了Request_i的时候，将会执行以下操作</p><ol type="1"><li>若<code>Request_i &gt; Need[i]</code>，出错</li><li>若<code>Request_i &gt; Available</code>，进程被阻塞</li><li>当上述两步均通过，则开始试分配<ol type="1"><li><code>Available -= Request_i</code></li><li><code>Allocation[i] += Request_i</code></li><li><code>Need[i] -= Request_i</code></li></ol></li><li>允许安全性检测算法</li><li>若第4步得到了一个安全的调度序列，则视作安全，分配内存，否则撤销该次预分配</li></ol><h5 id="安全性检测">安全性检测</h5><p>在这一步中我们将会引入两个向量，分别为</p><ul><li><code>work</code>向量，长度为n，其作为<code>Available</code>的一个替身</li><li><code>finish</code>向量，长度为m，其用于标记各进程的满足情况，初始化为全<code>false</code></li></ul><p>接下来我们需要按照如下的方式来对<code>finish</code>进行迭代<br />1. 找到一个同时满足<code>finish[i] = false</code>且<code>Need[i] &lt; work</code>的进程<code>i</code>，假定其很快就会完成他的工作并归还资源，然后进行<code>work += Allocation[i]</code>和<code>finish[i] = true</code>，若找不到，则到第3步 2. 回到第1步 3. 如果<code>finish</code>全部为<code>true</code>则说明安全，反之则为不安全</p><h1 id="总结">总结</h1><p>对于常规条件下的死锁问题，我们还会有很多的解决方案，包括上面提到的哲学家死锁问题，同样也还有其他的解法，本文的目的只在于介绍死锁问题和银行家算法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号量机制与管程</title>
    <link href="/2020/11/18/Semaphore-and-Monitor/"/>
    <url>/2020/11/18/Semaphore-and-Monitor/</url>
    
    <content type="html"><![CDATA[<h1 id="信号量机制">信号量机制</h1><p>信号量机制最早由提出图论的Dijkstra提出，其被广泛地使用于操作系统中用于解决同步问题。</p><span id="more"></span><h2 id="信号量简介">信号量简介</h2><p>信号量一般由以下几部分组成</p><ul><li>一个整形<code>sem</code><br />通常<code>sem</code>的值等于共享资源的数量</li><li>两个操作<ul><li>P操作(又名Wait)<br />P操作通常用于申请资源，其的主要过程一般为<ul><li><code>sem -= 1</code></li><li>当<code>sem &lt; 0</code>block当前进(线)程，并放入等待队列中</li></ul></li><li>V操作(又名Signal)<br />V操作通常用于释放资源，其的主要过程一般为<ul><li><code>sem += 1</code></li><li>当<code>sem &lt;=0</code>时从等待队列中取出一个进(线)程，并唤醒</li></ul></li></ul></li></ul><p>借助信号量机制，我们可以解决很多的多进(线)程间同步的问题。接下来我们将会使用几个例子来进一步地了解信号量的作用。</p><!-- more --><h2 id="生产者-消费者问题">生产者-消费者问题</h2><p>生产者-消费者问题是一个非常著名的多线程间同步的问题，接下来我们将会围绕这个问题探讨信号量机制的意义。</p><p>首先我们假设现在我们有一个盒子，x个消费者和y个生产者。并且我们规定同时可以有消费者从盒子中取出东西，同时只能由一位生产者向盒子中放入东西，且消费者和生产者同样不能同时从盒子中取出或者放入东西。</p><h3 id="情景0多消费者-无生产者-盒子内的资源无限">情景0：多消费者-无生产者-盒子内的资源无限</h3><p>情景0并不是定义上的生产者-消费者问题，这种情况只是提出用于具体了解信号量的工作方式的情景，故在本情景中我们假设同时只能有一位消费者从盒子中取出东西。<br />这种情况实际上可以退化为多个等价的个体竞争一个资源的情况，由于我们规定了盒子同时只能由一位消费者进行访问，所以我们这里就可以使用一个信号量表示盒子的占用情况，由上文中的信号量的定义我们可以得知当任何消费者对盒子进行访问后下一次对<code>res.wait()</code>的调用就会将新的进程阻塞，直到访问盒子的消费者调用<code>res.signal()</code>进行唤醒。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: Semaphore = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">consumer</span>()&#123;<br>    res.<span class="hljs-title function_ invoke__">wait</span>();<br>    <span class="hljs-comment">//对盒子中的资源进行消费</span><br>    res.<span class="hljs-title function_ invoke__">signal</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="情景1单消费者-单生产者-盒子容量为一">情景1：单消费者-单生产者-盒子容量为一</h3><p>从情景1开始才是真正意义上的消费者生产者问题，但是这里我们还是限制了消费者和生产者的数量均为1。对于本情景中的条件，我们可以构造得到下述的伪代码 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">full</span>: Semaphore = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">empty</span>: Semaphore = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">consumer</span>()&#123;<br>    full.<span class="hljs-title function_ invoke__">wait</span>();<br>    <span class="hljs-comment">//对盒子内的资源进行消费</span><br>    empty.<span class="hljs-title function_ invoke__">signal</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">provider</span>()&#123;<br>    empty.<span class="hljs-title function_ invoke__">wait</span>();<br>    <span class="hljs-comment">//向盒子中生产内容</span><br>    full.<span class="hljs-title function_ invoke__">signal</span>();<br>&#125;<br></code></pre></td></tr></table></figure> 从上面的代码就可以看到我们创建了两个信号量而非一个，原因也很简单，当盒子为空的时候消费者无法进行消费，当盒子为满的时候生产者无法进行生产，所以我们就可以让消费者对<code>full</code>作<code>wait()</code>标志空间已经被释放，同样生产者也可以使用<code>full.signal()</code>实现标志盒子中已经放入了资源。</p><h3 id="情景2多消费者-单生产者-盒子容量为n">情景2：多消费者-单生产者-盒子容量为n</h3><p>现在我们引入了多个消费者，我们知道当任何消费者在访问盒子的时候生产者都不能朝盒子中放入东西，但是我们只需要对上面的代码稍作修改即可解决这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">full</span>: Semaphore = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">empty</span>: Semaphore = n;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">mutex</span>: Semaphore = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">using</span>: Semaphore = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">count</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">consumer</span>()&#123;<br>    full.<span class="hljs-title function_ invoke__">wait</span>();<span class="hljs-comment">//当盒中有资源的时候</span><br>    mutex.<span class="hljs-title function_ invoke__">wait</span>();<span class="hljs-comment">//当生产者未占用(盒子空闲)</span><br>    using.<span class="hljs-title function_ invoke__">wait</span>();<br>    count += <span class="hljs-number">1</span>;<br>    using.<span class="hljs-title function_ invoke__">signal</span>();<br>    <span class="hljs-comment">//从此处才正式开始消费</span><br>    empty.<span class="hljs-title function_ invoke__">signal</span>();<br>    <span class="hljs-comment">//从盒子中取出资源</span><br>    using.<span class="hljs-title function_ invoke__">signal</span>();<br>    using.<span class="hljs-title function_ invoke__">wait</span>();<br>    count -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>&#123;<br>        mutex.<span class="hljs-title function_ invoke__">signal</span>();<span class="hljs-comment">//当所有消费者退出之后才释放mutex</span><br>    &#125;<br>    using.<span class="hljs-title function_ invoke__">signal</span>();<br>    <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">provider</span>()&#123;<br>    empty.<span class="hljs-title function_ invoke__">wait</span>();<span class="hljs-comment">//当盒子还有空间的时候</span><br>    mutex.<span class="hljs-title function_ invoke__">wait</span>();<span class="hljs-comment">//当消费者未占用(盒子空闲)</span><br>    <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>&#123;<br>        <span class="hljs-comment">//向盒子中放入东西</span><br>        full.<span class="hljs-title function_ invoke__">signal</span>();<br>    &#125;<br>    mutex.<span class="hljs-title function_ invoke__">signal</span>();   <br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码我们可以看到这里我们加入了两个信号量，一个负责控制消费者和生产者分别对共享的盒子的访问，另外一个用于控制消费者的计数器。<br />在上面的代码中我们实际上将多个消费者和单一生产者的问题抽象为了第一个消费者和生产者之间的问题，当消费者全部完成消费并退出之后我们才会释放掉<code>mutex</code>使得生产者可以向盒子中放入东西。同时务必要记住在多进(线)程对共享变量的操作中必须要使用信号量管理访问的权限。</p><h1 id="管程">管程</h1><p>管程实际上是一种对同步锁抽象得到的数据结构，一般来说管程有以下几种特征 - 同时只允许一个进(线)程在管程中执行 - 使用条件变量管理管程内进(线)程的执行 - 拥有一个<strong>入口队列</strong>用于进(线)程排队进行管程</p><p>实际上在本菜鸡看来管程的确有点难以理解，尤其是其的基本结构和几种不同的实现方式。</p><h2 id="条件变量">条件变量</h2><p>管程采用条件变量控制已经进入管程的进程的执行，条件变量本身的各种特征又和信号量有点相似但是完全不同 - <code>wait()</code>操作 - 表示当资源被占用导致自身阻塞，并将自身放入等待队列 - 执行<code>wait()</code>后将会从入口队列中唤醒一个新的进(线)程 - <code>signal()</code>操作 - 表示当前资源已经被使用完毕，唤醒等待队列中的一个进(线)程 - 当等待队列为空的时候<code>signal()</code>操作没有意义</p><p>这里我们就可以清楚地看到条件变量和信号量的区别，对于条件变量来说由于调用其的进(线)程已经在管程中，故其的<code>wait()</code>和<code>signal()</code>无需成对，且在条件变量执行完成<code>wait()</code>操作后进(线)程必定阻塞，但是对于信号量的<code>V()</code>操作则不一定会阻塞。且在条件变量执行<code>wait()</code>操作或<code>signal()</code>的时候已经默认获得了互斥锁。</p><p>光谈概念感觉管程本身还是比较晦涩的，下面还是会用著名的读者-写者问题讨论管程</p><h2 id="使用管程实现读者-写者问题">使用管程实现读者-写者问题</h2><p>通过使用管程，我们可以将读者-写者问题包装为一个面向对象的类 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Database</span>&#123;<br>    lock: Lock,<br>    AC: <span class="hljs-type">i32</span>, <span class="hljs-comment">//已经激活的读者</span><br>    AP: <span class="hljs-type">i32</span>, <span class="hljs-comment">//已经激活的写者</span><br>    WC: <span class="hljs-type">i32</span>, <span class="hljs-comment">//正在等待的读者</span><br>    WP: <span class="hljs-type">i32</span>, <span class="hljs-comment">//正在等待的写者</span><br>    buffer: <span class="hljs-type">i32</span>,<br>    Condition okToRead, okToWrite;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Database</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_consume</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">aquire</span>();<br>        <span class="hljs-title function_ invoke__">if</span> (WP + AP) &gt; <span class="hljs-number">0</span>&#123; <span class="hljs-comment">// 相当于还有写者处于激活状态的时候</span><br>            WC++;<br>            okToRead.<span class="hljs-title function_ invoke__">wait</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.lock); <span class="hljs-comment">// 将自己阻塞</span><br>            WC--;<br>        &#125;<br>        AC++;<span class="hljs-comment">//此处为未阻塞或者被唤醒</span><br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">release</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">end_consume</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">aquire</span>();<br>        AC--;<br>        <span class="hljs-keyword">if</span> AC == <span class="hljs-number">0</span> &amp;&amp; WP &gt; <span class="hljs-number">0</span>&#123;<br>            okToWrite.<span class="hljs-title function_ invoke__">signal</span>(); <span class="hljs-comment">// 当激活的读者退出的时候唤醒阻塞在队列中的写者</span><br>        &#125;<br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">release</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_produce</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">aquire</span>();<br>        <span class="hljs-title function_ invoke__">if</span> (WC + AC) &gt; <span class="hljs-number">0</span>&#123;<br>            WP++;<br>            okToWrite.<span class="hljs-title function_ invoke__">wait</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.lock); <span class="hljs-comment">// 同样当任何读者在执行的时候将自身阻塞</span><br>            WP--;<br>        &#125;<br>        AP++; <span class="hljs-comment">//此处为未阻塞或者被唤醒</span><br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">release</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">end_produce</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">aquire</span>();<br>        AP--;<br>        <span class="hljs-keyword">if</span> AP == <span class="hljs-number">0</span> &amp;&amp; WC &gt; <span class="hljs-number">0</span>&#123;<br>            okToRead.<span class="hljs-title function_ invoke__">signal</span>(); <span class="hljs-comment">// 当激活的写者退出的时候唤醒正在排队的读者线程</span><br>        &#125;<br>        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">release</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">start_consume</span>();<br>        <span class="hljs-comment">// do consume</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">end_consume</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">start_produce</span>();<br>        <span class="hljs-comment">// do produce</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">end_produce</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里我们使用了四个整形变量、一个锁和两个条件变量完成了对消费者-生产者的控制，我们可以看到对于读和写操作我们均使用两个函数来完成其的同步控制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
