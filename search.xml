<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AcWing 100.IncDec序列</title>
    <url>/2022/01/07/AcWing-100-IncDec%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>算法基于查分数组的前缀和即是原数组的思想进行。</p>
<p>对于在原始数组上[m, n]区间每个数字+n，体现在差分数组上即第m个数字+n同时第n+1个数字-n。</p>
<hr />
<p>本题提供的基本操作可以使用差分进行表示，即每次+1或-1的操作可以在差分数组上对两端的数字进行操作实现，对于整个差分数组可以用一个折线图进行表示，可以发现当所有的数字经过该操作到达相同值所需步骤最少的过程必然是所有数字达到重叠的区域内。</p>
<!---more--->
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pos = <span class="number">0</span>, neg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; --i) a[i] -= a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) pos += a[i];</span><br><span class="line">        <span class="keyword">else</span> neg -= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(pos, neg) + <span class="built_in">abs</span>(pos - neg) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="built_in">abs</span>(pos - neg) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 105. 七夕祭</title>
    <url>/2022/01/09/AcWing-105-%E4%B8%83%E5%A4%95%E7%A5%AD/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>考虑到本题的实际操作机制，行内相邻交换不会导致列分布变化、列内交换不会导致行分布变化，根据这点我们可以将本题拆分为分别对行和列做循环交换操作。</p>
<p>假设一个环形结构<span class="math inline">\([a_1, a_2 ... a_n]\)</span>，需要将其中所有的数字通过相邻数字间的交换变为<span class="math inline">\(a\)</span>，假设从<span class="math inline">\(a_i \to a_{i + 1}\)</span>传递<span class="math inline">\(x_i\)</span>个数字(<span class="math inline">\(x_i\)</span>可正可负，且<span class="math inline">\(a_n\to a_1\)</span>为<span class="math inline">\(x_n\)</span>)则有</p>
<p><span class="math display">\[a_1 + x_n - x_1 = a \\ a_2 + x_1 - x_2 = a \\ ... \\a_n + x_{n - 1} - x_n = a\]</span></p>
<p>整理得</p>
<p><span class="math display">\[x_1 - x_n = a_1 - a \\ x_2 - x_1 = a_2 - a \\ ... \\ x_n - x_{n - 1} = a_n - a\]</span></p>
<p>由于希望求得最小的操作次数，即题目希望求得最小的<span class="math inline">\(|x_1| + |x_2| + ... +|x_n|\)</span>则有</p>
<p><span class="math display">\[x_1 = x_1 \\ x_2 = x_1 - (a - a_2) \\ x_3 = x_2 - (a - a_3) = x_1 - (2a - a_2 - a_3) \\ ... \\ x_n = x_{n - 1} - (a - a_n) = ... = x_1 - ((n - 1)a-a_2-a_3 ... -a_n)\]</span></p>
<p>即最终上面的式子被转化为了<span class="math inline">\(|x_1| + |x_1 - (a-a_2)| ...+|x_1 - [(n - 1)a - a_2 - a_3 ... -a_n]|\)</span>最终变为了货仓选址问题。</p>
<!---more--->
<h1 id="代码实现">代码实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">int</span> r[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> avg, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = avg - a[i] + buf[i - <span class="number">1</span>]; <span class="comment">// buf[1] = a - a_2 buf[2] = 2a - a_2 - a_3 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(buf + <span class="number">1</span>, buf + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="number">1</span> + cnt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(buf[i] - buf[mid]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        r[x] ++;</span><br><span class="line">        c[y] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> col_res = <span class="number">0</span>, row_res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col_avg = <span class="number">0</span>, row_avg = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t % m &amp;&amp; t % n) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t % m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;row &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">compute</span>(r, t / n, n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t % n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;column &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">compute</span>(c, t / m, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;both &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">compute</span>(r, t / n, n) + <span class="built_in">compute</span>(c, t / m, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1068. 环形石子合并</title>
    <url>/2022/01/09/AcWing-1068-%E7%8E%AF%E5%BD%A2%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>对于石子合并，对于第<span class="math inline">\(i\)</span>和第<span class="math inline">\(i + 1\)</span>两堆石子进行合并，将会得到得分<span class="math inline">\(a[i] + a[i + 1]\)</span>。</p>
<p>即可以考虑对于第<span class="math inline">\(1...n\)</span>号石子，最后一次合并的得分必然为所有石子数量的总和，即可以选择一个中间位置<span class="math inline">\(i\)</span>，即第<span class="math inline">\(i\)</span>次合并后的总得分为<span class="math inline">\(sc[1...i] + sc[i + 1...n] + a[1 ... n]\)</span>即为前半段的得分加上后半段的得分再加上当前石子数量的总和。</p>
<p>针对求和问题，可以考虑直接求区间和，即有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[i] += a[i - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>则对于第<span class="math inline">\(i\)</span>到第<span class="math inline">\(j\)</span>的总和为<span class="math inline">\(a[j] - a[i - 1]\)</span>。</p>
<p>而对于划分问题，可以考虑dp数组的定义，<code>dp[i][j]</code>为第<span class="math inline">\(i\)</span>到第<span class="math inline">\(j\)</span>号石子合并的得分。得到转移方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j], d[i][k] + dp[k + <span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure>
<p>同时对于区间DP问题，我们需要明确需要从小区间向大区间遍历，即<code>for</code>循环遍历的过程是分别遍历<strong>区间长度</strong>和<strong>区间左端点</strong>，并使用二者计算得到区间右端点。</p>
<p>另外本题中的数组为一个循环数组，为了实现循环数组中的区间DP，可以考虑将数组重复一遍并限定区间DP的长度控制在<code>n</code>，实现对于环形数组的处理</p>
<p>#代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">420</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], dpmx[N][N], dpmn[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], a[i + n] = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; ++i) a[i] += a[i - <span class="number">1</span>];<span class="comment">//计算区间和</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dpmn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dpmn);<span class="comment">//初始化最小值数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; r = l + len - <span class="number">1</span>, r &lt; n &lt;&lt; <span class="number">1</span>; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) dpmx[l][l] = dpmn[l][l] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dpmx[l][r] = <span class="built_in">max</span>(dpmx[l][r], dpmx[l][k] + dpmx[k + <span class="number">1</span>][r] + a[r] - a[l - <span class="number">1</span>]);</span><br><span class="line">                    dpmn[l][r] = <span class="built_in">min</span>(dpmn[l][r], dpmn[l][k] + dpmn[k + <span class="number">1</span>][r] + a[r] - a[l - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> minv = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, dpmx[l][l + n - <span class="number">1</span>]);</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, dpmn[l][l + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; minv &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>区间DP</tag>
        <tag>DP</tag>
        <tag>区间和</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1076.迷宫问题</title>
    <url>/2022/01/24/AcWing-1076-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>本题实际上就是Dijkstra算法的一个小扩展，需要加入对于路径记录的支持。故可以考虑开辟一个<code>pre[][]</code>数组保存当前点需要走的下一步，通过迭代得到从起点到终点的路径即可。</p>
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line">PII pre[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;PII&gt; q, tq;</span><br><span class="line">    PII tep = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">fill</span>(pre[<span class="number">0</span>], pre[<span class="number">0</span>] + n * n, tep);</span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(&#123;n - <span class="number">1</span>, n - <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="comment">//st[n - 1][n - 1] = true;</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[t.x][t.y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; t.x &lt;&lt; &#x27; &#x27; &lt;&lt; t.y &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.x + dx[i], y = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= n || g[x][y] || st[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            pre[x][y] = t;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    PII end = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(end.x != n - <span class="number">1</span> || end.y != n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pre[end.x][end.y].x, pre[end.x][end.y].y);</span><br><span class="line">        <span class="keyword">int</span> x = end.x, y = end.y;</span><br><span class="line">        end.x = pre[x][y].x, end.y = pre[x][y].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt; n; ++j)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; &#x27;[&#x27; &lt;&lt; pre[i][j].x &lt;&lt; &#x27;,&#x27; &lt;&lt; pre[i][j].y &lt;&lt; &quot;] &quot;;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1097.池塘计数</title>
    <url>/2022/01/19/AcWing-1097-%E6%B1%A0%E5%A1%98%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目思路">题目思路</h1>
<p>本题目较为简单，但是题目给出的数据若采用递归进行实现会导致<code>stack overflow</code>，故选择使用迭代算法实现。即采用BFS的思想进行计算，通过一个队列存储当前待访问的点并持续进行入队出队操作最终完成洪泛。</p>
<h1 id="实现代码">实现代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">&#x27;.&#x27;</span>) g[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> g[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                visited.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                g[i][j] = <span class="number">0</span>;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!visited.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ox = visited.<span class="built_in">front</span>().first, oy = visited.<span class="built_in">front</span>().second;</span><br><span class="line">                visited.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">8</span>; ++s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = ox + x[s];</span><br><span class="line">                    <span class="keyword">int</span> ny = oy + y[s];</span><br><span class="line">                    <span class="keyword">if</span> (g[nx][ny]) visited.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                    g[nx][ny] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1098.城堡问题</title>
    <url>/2022/01/19/AcWing-1098-%E5%9F%8E%E5%A0%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>本题实际上不难，和1097解法相同，唯一需要注意的问题是本题使用多个数字之和表示每个房间的墙的情况。但是根据题意实际上就是用一个四位二进制表示，直接按位判断就可以。</p>
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N], v[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, mxar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> arr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!v[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                visited.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!visited.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ox = visited.<span class="built_in">front</span>().first, oy = visited.<span class="built_in">front</span>().second;</span><br><span class="line">                visited.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (v[ox][oy]) <span class="keyword">continue</span>;</span><br><span class="line">                v[ox][oy] = <span class="number">1</span>;</span><br><span class="line">                arr ++;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">4</span>; ++s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = ox + x[s], ny = oy + y[s];</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt; n || ny &gt; m || nx &lt; <span class="number">1</span> || ny &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!(g[ox][oy] &gt;&gt; s &amp; <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; nx &lt;&lt; &#x27; &#x27; &lt;&lt; ny &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mxar = <span class="built_in">max</span>(mxar, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; mxar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1100.抓住那头牛</title>
    <url>/2022/01/24/AcWing-1100-%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>这道题更为简单粗暴，相比188和1076的二维搜索问题，本题将搜索放到了一维层面，实际上更加简单了，具体思路同dijkstra模板</p>
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> dist[N], st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t - <span class="number">1</span> &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            dist[t - <span class="number">1</span>] = <span class="built_in">min</span>(dist[t - <span class="number">1</span>], dist[t] + <span class="number">1</span>);</span><br><span class="line">            q.<span class="built_in">push</span>(t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t + <span class="number">1</span> &lt; N)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t + <span class="number">1</span>] = <span class="built_in">min</span>(dist[t + <span class="number">1</span>], dist[t] + <span class="number">1</span>);</span><br><span class="line">            q.<span class="built_in">push</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t * <span class="number">2</span> &lt; N)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t * <span class="number">2</span>] = <span class="built_in">min</span>(dist[t * <span class="number">2</span>], dist[t] + <span class="number">1</span>);</span><br><span class="line">            q.<span class="built_in">push</span>(t * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dist[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1106.山峰和山谷</title>
    <url>/2022/01/19/AcWing-1106-%E5%B1%B1%E5%B3%B0%E5%92%8C%E5%B1%B1%E8%B0%B7/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>本题实际上只是在1097和1098的基础上增加了少量的额外操作。对于判断山峰山谷的操作只需要在确定连通域的同时确定在该连通域边界是否存在更高或更低的格子再进行判断。</p>
<h1 id="代码实现">代码实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N], st[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> peak = <span class="number">0</span>, vally = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">                st[t.first][t.second] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = t.first - <span class="number">1</span>; x &lt;= t.first + <span class="number">1</span>; ++x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = t.second - <span class="number">1</span>; y &lt;= t.second + <span class="number">1</span>; ++y)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; n || y &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (g[x][y] &gt; g[t.first][t.second]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (g[x][y] &lt; g[t.first][t.second]) has_lower = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span> q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!(has_lower &amp;&amp; has_higher) &amp;&amp; (has_higher || has_lower))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (has_higher) vally ++;</span><br><span class="line">                <span class="keyword">if</span> (has_lower) peak ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (peak || vally)</span><br><span class="line">        cout &lt;&lt; peak &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; vally;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;1 1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 188.武士风度的牛</title>
    <url>/2022/01/24/AcWing-188-%E6%AD%A6%E5%A3%AB%E9%A3%8E%E5%BA%A6%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>还是熟悉的Dijkstra，但是这次的行为模式变成了象棋中🐎的行进方式罢了。</p>
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">160</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N], n, m, dist[N][N], st[N][N];</span><br><span class="line">PII init, target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(init);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    dist[init.x][init.y] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[t.x][t.y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.x + dx[i], y = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= m || g[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            dist[x][y] = <span class="built_in">min</span>(dist[x][y], dist[t.x][t.y] + <span class="number">1</span>);</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">&#x27;*&#x27;</span>) g[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                g[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="string">&#x27;K&#x27;</span>) init = &#123;i, j&#125;;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;H&#x27;</span>) target = &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dist[target.x][target.y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 320.能量项链</title>
    <url>/2022/01/10/AcWing-320-%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE/</url>
    <content><![CDATA[<h1 id="算法思路">算法思路</h1>
<p>本题是一道经典的区间DP问题。</p>
<p>对于一串珠子<span class="math inline">\((i_1, j_1), (i_2, j_2)...(i_n, j_n)\)</span>假设对其中任意一个区间进行合并，例如对<span class="math inline">\((i_k, j_k)...(i_s, j_s)\)</span>这一段的所有珠子进行合并，最后一次合并的值（释放的能量）取决于合并的顺序。但是同样可以考虑对合并点进行枚举得到结果。</p>
<p>考虑当合并区间首尾确定的情况下，该次合并的结果只与其的合并的中心点的值有关，故可以考虑在区间DP的过程中枚举合并点得到结果。</p>
<p>而考虑到本题每个被合并的珠子具有两个参数，合并的过程可以被视作<span class="math inline">\(i_k, j_k(i_{k+1}), j_{k + 1} \to i_k, j_{k + 1}\)</span>而中间的元素将会被两边共用，问题可以从合并n个带有两个参数的珠子转化为合并n+1个带有一个参数的石子的过程，且被选为分割点的石子将会被两边共用。</p>
<!---more--->
<h1 id="算法实现">算法实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], a[i + n] = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n + <span class="number">1</span>; ++len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; r = l + len - <span class="number">1</span>, r &lt;= n &lt;&lt; <span class="number">1</span>; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) dp[l][l] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt; r; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[l][r] = <span class="built_in">max</span>(dp[l][r], dp[l][k] + dp[k][r] + a[l] * a[r] * a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, dp[l][l + n]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>区间DP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 3580.整数配对</title>
    <url>/2021/05/27/AcWing-3580-%E6%95%B4%E6%95%B0%E9%85%8D%E5%AF%B9/</url>
    <content><![CDATA[<h2 id="题目详情">题目详情</h2>
<p>给定 <span class="math inline">\(n\)</span> 个整数 <span class="math inline">\(a_1,a_2,…,a_n\)</span>, <span class="math inline">\(n\)</span> 为偶数。</p>
<p>现在要将它们两两配对，组成 <span class="math inline">\(n2\)</span> 个数对。</p>
<p><span class="math inline">\(ai\)</span> 和 <span class="math inline">\(a_j\)</span> 能够配对，当且仅当 <span class="math inline">\(a_i=a_j\)</span>。</p>
<p>每次增加操作可以使其中的任意一个数 <span class="math inline">\(a_i\)</span> 加一。</p>
<p>请问，要使得 <span class="math inline">\(n\)</span> 个整数能够成功组成 <span class="math inline">\(\frac{n}{2}\)</span> 个数对，至少要进行多少次增加操作。</p>
<span id="more"></span>
<h3 id="输入格式">输入格式</h3>
<p>第一行包含整数 <span class="math inline">\(n\)</span>。</p>
<p>第二行包含 <span class="math inline">\(n\)</span> 个整数 <span class="math inline">\(a_1,a_2,…,a_n\)</span>。</p>
<h3 id="输出格式">输出格式</h3>
<p>一个整数，表示所需最少操作次数</p>
<h3 id="数据范围">数据范围</h3>
<p><span class="math display">\[1\leq n\leq10^5\]</span>, <span class="math inline">\(1\leq a_i\leq10^4\)</span></p>
<h3 id="输入样例1">输入样例1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 10 2 3 14 5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例1">输出样例1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="输入样例2">输入样例2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure>
<h3 id="输出样例2">输出样例2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">99</span><br></pre></td></tr></table></figure>
<h2 id="题目思路">题目思路</h2>
<p>本题中考虑到需要使用最小的修改可以实现所有的整数配对，故实际上最优解一定是将某个数字<code>a[i]</code>修改为离他最近的一个数字<code>a[j]</code>。</p>
<p>我们可以将排序好的所有数字放到一个数轴上，就可以看到下面的情况</p>
<figure>
<img src="https://i.loli.net/2021/05/27/a83RVLOoG4hKdYM.png" alt="" /><figcaption>image.png</figcaption>
</figure>
<p>为了使得我们的修改量最少，即数轴上每个点找到和他配对的一个点所需移动的总距离最小，此时我们需要尽量少地越过其他的点，故可以证明对于每个<code>a[i]</code>都必须找其相邻的点进行配对。</p>
<p>假设我们使用蓝色的方法进行配对，此时<code>a[1]</code>必须越过<code>a[2]</code>和<code>a[3]</code>寻找与其配对的点，此时并非最小。</p>
<figure>
<img src="/Users/cydia2001/Library/Application%20Support/typora-user-images/image-20210527191959278.png" alt="" /><figcaption>image-20210527191959278</figcaption>
</figure>
<p>同样对于后面的每一个点均适用于该种情况。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 532. 货币系统</title>
    <url>/2021/05/22/AcWing-532/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>在网友的国度中共有<code>n</code>种不同面额的货币，第 <code>i</code> 种货币的面额为<code>a[i]</code>，你可以假设每一种货币都有无穷多张。</p>
<p>为了方便，我们把货币种数为<code>n</code>、面额数组为<code>a[1..n]</code>的货币系统记作<code>(n,a)</code> 。 </p>
<p>在一个完善的货币系统中，每一个非负整数的金额 <code>x</code> 都应该可以被表示出，即对每一个非负整数 <code>x</code>，都存在 nn 个非负整数 <code>t[i]</code> 满足 <code>a[i]*t[i]</code> 的和为 <code>x</code>。</p>
<p>然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 <code>x</code> 不能被该货币系统表示出。</p>
<p>例如在货币系统 <code>n=3,a=[2,5,9]</code> 中，金额 <code>1,3</code> 就无法被表示出来。 </p>
<p>两个货币系统 <code>(n,a)</code> 和 <code>(m,b)</code> 是等价的，当且仅当对于任意非负整数 <code>x</code>，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p>
<p>现在网友们打算简化一下货币系统。</p>
<p>他们希望找到一个货币系统 <code>(m,b)</code>，满足 <code>(m,b)</code> 与原来的货币系统 <code>(n,a)</code> 等价，且 <code>m</code> 尽可能的小。</p>
<p>他们希望你来协助完成这个艰巨的任务：找到最小的 <code>m</code>。</p>
<span id="more"></span>
<h2 id="输入格式">输入格式</h2>
<p>输入文件的第一行包含一个整数 <code>T</code>，表示数据的组数。</p>
<p>接下来按照如下格式分别给出 <code>T</code> 组数据。 </p>
<p>每组数据的第一行包含一个正整数 <code>n</code>。</p>
<p>接下来一行包含 <code>n</code> 个由空格隔开的正整数 <code>a[i]</code>。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出文件共有 <code>T</code> 行，对于每组数据，输出一行一个正整数，表示所有与 <code>(n,a)</code> 等价的货币系统 <code>(m,b)</code> 中，最小的 <code>m</code>。</p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math display">\[1 \leq n \leq 100\]</span></p>
<p><span class="math display">\[1 \leq a[i]\leq 25000\]</span></p>
<p><span class="math display">\[1 \leq T \leq 20\]</span></p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">3 19 10 6 </span><br><span class="line">5 </span><br><span class="line">11 29 13 19 17 </span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="题目思路">题目思路</h2>
<p>本题中的货币系统实际上就是在给定的一串数字中去掉所有的可以被其他任意数字表示出的数字。故可以考虑使用动态规划求出使用该列数字可以表出的所有数字的方案数量，当且仅当给出数字的表示方案数量大于1的时候，即该数字除了可以被自己表出还可以被其他数字组合表出的时候即可以去掉。</p>
<p>根据以上思路该题将会退化为一个完全背包组合问题，代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25010</span>, CNT = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">int</span> a[CNT];<span class="keyword">long</span> <span class="keyword">long</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fill</span>(f, f + N, <span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i]; mx = <span class="built_in">max</span>(a[i], mx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= mx; ++j) f[j] += f[j - a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[a[i]] &gt; <span class="number">1</span>) res--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 91.最短Hamilton路径</title>
    <url>/2022/01/07/AcWing-91-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="算法逻辑">算法逻辑</h1>
<p>本题采用状态压缩DP方式实现。</p>
<p>定义状态<code>i</code>为一个二进制串，其中1代表已访问的点，0代表未访问的点。DP数组定义为 当前状态*当前正在访问的点。</p>
<span id="more"></span>
<h1 id="代码实现">代码实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N], dp[M][N];</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + M * N, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// initial_data</span></span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read graph</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) <span class="comment">// for each status i</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) <span class="comment">// arrived j</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>) <span class="comment">// arrived k but not arrived j</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - (<span class="number">1</span> &lt;&lt; j)][k] + g[j][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
        <tag>DP</tag>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2021/06/30/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法简介">算法简介</h2>
<p>KMP算法解决的问题主要在于如何实现在一个较长的字符串中匹配得到一个较短的字符串。</p>
<p>我们知道对于子串匹配的问题，常用的暴力解法是不断枚举起点，并反复遍历字符串以确定是否匹配，而KMP算法则可以简化这一个过程。该算法可以自动跳过一些可能会导致重复匹配的字符串从而减少匹配的次数。</p>
<span id="more"></span>
<h2 id="算法详解">算法详解</h2>
<p>首先我们假设我们待匹配的字符串是<code>s = abababcafc</code>而子串为<code>p = ababc</code>，整个匹配过程如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abababcafc</span><br><span class="line">ababc</span><br><span class="line">    ^不匹配</span><br><span class="line"></span><br><span class="line">abababcafc</span><br><span class="line">  ababc</span><br><span class="line">       ^匹配成功</span><br></pre></td></tr></table></figure>
<p>我们可以发现与暴力匹配不同，字符串直接向后移动了两位然后完成了匹配，我们可以观察第二个字符串存在这样的性质</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab|ab|abcafc</span><br><span class="line">^1 ^2</span><br><span class="line">   ab|abc</span><br><span class="line">   ^3</span><br></pre></td></tr></table></figure>
<p>我们可以发现在这个串中1、2、3三个字符串均相同，实际上这里就是KMP移动字符串的依据，在第一次匹配的过程中我们发现字符串<code>0-1</code>位和<code>2-3</code>位相同，而第一次又成功匹配了<code>0-3</code>位的字符串，所以说实际上下一次进行匹配的时候我们的<code>0-1</code>位可以直接移动到当前<code>2-3</code>位的位置上，然后从<code>2</code>位重新开始匹配，从而减少了匹配的次数。</p>
<p>而此时我们便会面临一个问题，如何获得上面我们需要的这种相同的关系，此时我们可以考虑定义一个数组<code>next[]</code>，假设<code>next[j]</code>表示以<code>j</code>在<code>p</code>串中以<code>j</code>结尾的满足其<strong>前缀</strong>与<strong>后缀</strong>相同子串中前缀结尾的<strong>索引</strong>，而后续匹配时的跳转操作可以直接使用这个数组完成跳转。接下来我们可以尝试来计算这个数组。</p>
<h3 id="next数组的计算方法">next数组的计算方法</h3>
<p>为了推导方便，此时我们假设<code>p=ababdababaa</code>，实际使用的时候我们只需要知道如何从<code>next[0~i - 1]</code>推得<code>next[i]</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//此时我们假设我们已知next[8]推导next[9]，我们有如下字符串，可以看到next[8] = 3</span><br><span class="line">|aba|bd|aba|baa</span><br><span class="line">//而正因为我们已知了next[8] = 3，我们知道p[1:3] == p[6:8]同时p[1:4] != p[5:8]，接下来我们继续向后读入一个字符</span><br><span class="line">|aba|bd|aba|baa</span><br><span class="line">     ^      ^p[9]</span><br><span class="line">     p[next[9 - 1] + 1]</span><br><span class="line">//可以发现此时p[next[9 - 1] + 1] == p[9]，故我们可以得到p[9] = p[8] + 1</span><br></pre></td></tr></table></figure>
<p>但是我们面临着一个问题，如果第一次匹配不成功应该怎么解决，我们假设下面一种情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|abab|d|abab|aa</span><br><span class="line"> 1234 5 6789 01</span><br><span class="line">//此时我们需要计算next[10]，但是很不幸p[next[10 - 1] + 1] != p[10]</span><br></pre></td></tr></table></figure>
<p>为了求解得到<code>next[10]</code>，我们只能退而求其次，去尝试更短的子串看看是否可以求解。根据<code>next[9]=4</code>我们可以知道<code>p[1:4] == p[6:9]</code>，而我们又可以发现<code>next[next[9]] = next[4] = 2</code>，即<code>p[1:2] == p[3:4]</code>，而根据<code>next[9]</code>的定义我们又知道<code>p[3:4] == p[8:9]</code>，同时<code>p[next[next[9]] + 1] == p[10]</code>，所以我们可以得到<code>p[1:3] == p[8:10]</code>即<code>next[10] = 3</code>。</p>
<p>而上面的推导存在一个边界，即当<code>next[next[....]] = 0</code>时，此时不再指望<code>next[0~n-1]</code>会对<code>next[n]</code>做出任何贡献。</p>
<h3 id="next数组构造代码实现">next数组构造代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; ++i) <span class="comment">// 假设字符串长度为m，且下标起点为1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j]; <span class="comment">// 当出现退无可退（即j回到了0的位置）或匹配成功的时候跳出循环</span></span><br><span class="line">  <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++; <span class="comment">// 对应了匹配成功的情况</span></span><br><span class="line">  next[i] = j; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配过程">匹配过程</h3>
<p>既然此时我们获得了<code>next[]</code>，我们便可以开始尝试进行匹配<code>s</code>和<code>p</code>了，匹配过程与<code>next[]</code>构造的过程类似，即在出现第一个无法匹配即<code>s[i] != p[j]</code>或者匹配完全时，将会尝试最大程度的向前移动，这里我们还是继续假设待匹配的字符串是<code>s = ababababfab</code>而子串为<code>p = ababf</code>，匹配的过程可以像这样进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ababababfab</span><br><span class="line">ababf</span><br><span class="line">    ^出现不匹配</span><br></pre></td></tr></table></figure>
<p>此时我们要开始找最长的可以移动的距离，我们可以发现<code>s[5] == p[3]</code>，而同时存在<code>p[1:2] == p[3:4]</code>，故此时我们可以作如下的移动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ababababfab</span><br><span class="line">  ababf</span><br><span class="line">     ^下一个判断是否匹配的字符</span><br></pre></td></tr></table></figure>
<p>可以看到这样我们就成功实现了利用<code>next[]</code>一次性移动多位的操作。这里的思想与求<code>next[]</code>的过程类似，即我们实际上是在<code>s</code>上搜索一个与当前已知前缀相互匹配的后缀，假设存在任何一个可以相互匹配的前后缀即可直接将字符串开头移动到求得的后缀的开头的位置。</p>
<h3 id="匹配过程代码实现">匹配过程代码实现</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 1, j = 0; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	while(j &amp;&amp; s[i] != p[j + 1]) j = next[j]; // 在s上匹配一个p的后缀，而由于最终求得的前后缀是前面next数组得到的前后缀，故可以直接获得前文中三个子串相互的关系。</span><br><span class="line">	if (s[i] == p[j + 1]) j ++; // 若当前位置匹配成功则后移待匹配的指针</span><br><span class="line">	if (j == m) // j到达了p的末尾</span><br><span class="line">	&#123;</span><br><span class="line">		// 匹配成功</span><br><span class="line">		j = ne[j]; // 继续后移</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp算法的应用">KMP算法的应用</h2>
<h3 id="状态机kmpacwing-1052.-设计密码">状态机+KMP(AcWing 1052. 设计密码)</h3>
<p>该题目中实际上可以将我们需要求得的密码视作<code>n</code>次状态转换，其中第一个状态即<code>state[0]</code>就是不存在任何匹配的状态，而由于我们的要求是不能匹配子串，假设子串长度为<code>m</code>，故我们要求不能到达<code>state[m]</code>。</p>
<p>由于密码的每一位都存在26种情况（题目中密码组成是全小写字母），故对于每一个状态均存在26种转移方式。而我们又知道对于KMP算法实际上每次在计算匹配情况的时候其都只会关心待匹配串<code>s</code>的一个字母，根据这种性质我们可以利用KMP的匹配方式求得每种状态最远可以匹配的子串长度，只要求得的长度没有到达<code>n</code>那就是一种可用的密码。</p>
<p>首先我们同样可以计算出KMP所需的<code>next[]</code>，然后可以进行状态转移</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="comment">// 这里我们假设不能被包含的子串长度为m</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u = j; <span class="comment">// 这里的u即为我们当前k可以匹配到的最长子串长度，也就是说如果直接得到k == p[j + 1]时将会直接得到最大匹配长度</span></span><br><span class="line">			<span class="keyword">while</span>(u &amp;&amp; k != p[u + <span class="number">1</span>]) u = next[u];</span><br><span class="line">			<span class="keyword">if</span> (k == p[u + <span class="number">1</span>]) u++;</span><br><span class="line">			<span class="keyword">if</span> (u &lt; m) f[i + <span class="number">1</span>][u] = (f[i + <span class="number">1</span>][u] + f[i + <span class="number">1</span>][j]) % MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的Rust生活：00-前言</title>
    <url>/2020/11/20/Rust-00/</url>
    <content><![CDATA[<h1 id="关于我为什么要写这个系列的博客">关于我为什么要写这个系列的博客</h1>
<p>我只是一位Rust初学者，写这篇博客一方面是为了记录自己Rust的学习历程，另外一方面也希望可以为后来学Rust的人指出一条路，虽然我觉得我还不够格被称为领路人，但是我希望终有一天也可以称为像<a href="https://github.com/ZhangHanDong/">张汉东</a>这样的大神，能够吃透Rust这门语言，让Rust的编译器成为自己的朋友而并非敌人，虽然在学习的前期她的确像一个敌人那样阻碍着代码的编译(笑)。总之这个系列的博客将会成为我Rust学习之路的一个记录，也希望它可以给每一个人帮助。</p>
<span id="more"></span>
<h1 id="关于我为什么会选择rust">关于我为什么会选择Rust</h1>
<ol type="1">
<li>她是安全的</li>
<li>她是全新的</li>
<li>她是社区驱动的</li>
<li>她是奇妙的</li>
<li>她会教会你如何写出安全的代码</li>
</ol>
<h1 id="关于本系列博客的一些说明">关于本系列博客的一些说明</h1>
<ol type="1">
<li>所有的代码均会在对应博客写作时的Rust Stable版本下成功运行</li>
<li>我将会完全从一个初学者的角度来看Rust，所以自然也没有那些书籍写的那么全面</li>
<li>主要的内容将会参考<a href="https://book.douban.com/subject/30312231/">《深入浅出Rust》</a>和<a href="https://book.douban.com/subject/30418895/">《Rust编程之道》</a>，也推荐大家可以去看看</li>
<li>一切的内容都是兴趣使然的</li>
<li>欢迎提issue</li>
</ol>
<h1 id="关于如何安装rust">关于如何安装Rust</h1>
<p>出门左转<a href="https://www.rust-lang.org/">Rust官网</a>，右上角切换到中文，相信大家都看得懂的吧(笑)</p>
<h1 id="关于用什么ide">关于用什么IDE</h1>
<p>本人目前使用的是CLion配合Rust插件，之前也接触过vscode + rust(rls)插件和vscode + rust-analyzer这两种搭配，具体那种好用我也不好说，但是如果真的想要最完整的IDE体验的话本人更推荐使用CLion+Rust插件的组合，不过基于开源、美观(主要是美观)的原则，我更倾向于vscode + rust-analyzer这种搭配。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的Rust生活：01-基本类型与基本运算符</title>
    <url>/2020/11/21/Rust-01/</url>
    <content><![CDATA[<h1 id="rust中的基本数据类型">Rust中的基本数据类型</h1>
<p>Rust中的基本数据类型和大多数的语言一样，都可以简单的被分为整型、浮点型、布尔型等等，同时Rust还有一些专属于自身的一些很奇妙的类型，包括<code>Option&lt;T&gt;</code>,<code>Box&lt;T&gt;</code>等等。</p>
<p>通常Rust中的类型对应的符号为：</p>
<ul>
<li>有符号整型：<code>isize</code>,<code>i8</code>,<code>i16</code>,<code>i32</code>,<code>i64</code>,<code>i128</code></li>
<li>无符号整型：<code>usize</code>,<code>u8</code>,<code>u16</code>,<code>u32</code>,<code>u64</code>,<code>u128</code></li>
<li>浮点型：<code>f32</code>,<code>f64</code></li>
<li>布尔型：<code>bool</code></li>
<li>unit类型：<code>()</code></li>
<li>引用：<code>&amp;T</code>,<code>&amp;mut T</code></li>
<li>裸指针：<code>*mut T</code>,<code>*const T</code></li>
<li><code>!</code></li>
</ul>
<span id="more"></span>
<p>这里值得一提的是，Rust中的<code>!</code>类型在多数情况下实际上代表了<strong>不会返回</strong>，他的功能包括在<code>match()</code>块中实现对各种条件返回类型的补全(因为Rust中对于<code>match()</code>块要求每个分支的返回类型必须相同，当某一个分支不会返回而是导致程序异常退出的时候则可以通过返回一个<code>!</code>来通过编译器检查)</p>
<p>另外对于Rust还有以下几种常用的类型：</p>
<ul>
<li><code>Option&lt;T&gt;</code>：Rust用于解决"空"的一个方案，一个<code>Option&lt;T&gt;</code>枚举量可以是一个<code>Option&lt;T&gt;::Some(n)</code>代表非空，也可以是一个<code>Option&lt;T&gt;::None</code>表示空</li>
<li><code>Box&lt;T&gt;</code>：堆上分配的指针</li>
<li><code>Rc&lt;T&gt;</code>,<code>Arc&lt;T&gt;</code>：智能指针(可以这么想)</li>
<li><code>RefCell&lt;T&gt;</code>：更加神奇的指针(之后会讨论的)</li>
<li>以及很多</li>
</ul>
<p>可以说Rust为了保证其基本的安全可以说是费尽了心思，搞出了一大堆用于应对各种情况的类型，某种意义上这也是Rust难学的一个重要原因。</p>
<h1 id="类型强制转换">类型强制转换</h1>
<p>类型强制转换可以说是几乎现役的所有程序语言必备的功能，Rust自然也不例外。<br />
对于Rust其使用了关键字<code>as</code>用于类型转换。对于Rust来说强制类型转换同样需要各个类型之间是支持强制类型转换的，不然编译器报错警告。同时Rust对于从高类型向低类型转换的时候不会报错，最多一个warning了事，所以也不要指望编译器会帮你解决把一个<code>i32</code>转换到<code>i8</code>导致的溢出问题。</p>
<h1 id="运算符">运算符</h1>
<p>作为一款合格的程序语言，Rust自然也具有完备的运算符系统，考虑到运算符的数量实在是太多了(主要是懒)，<a href="https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html">这里</a>是官方的运算符列表，各位可以作为参考资料。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的Rust生活：02-函数</title>
    <url>/2020/11/23/Rust-02/</url>
    <content><![CDATA[<h1 id="函数是什么">函数是什么</h1>
<p>相信各位学Rust的读者应该多少接触过至少一门程序语言，不过这里我还是会按照我的理解尽可能的去为函数做一个相对更为简单的定义。</p>
<p>对于Rust来说，函数的意义与大多数的程序语言都很相似，我们可以将其视作程序中的一个功能模块。这个功能模块可以对一些我们会反复使用的代码进行封装，从而大幅度简化程序的开发过程。</p>
<span id="more"></span>
<h1 id="rust的函数长什么样">Rust的函数长什么样</h1>
<p>Rust中声明一个函数需要用到<code>fn</code>关键字，通常一个函数的样子形如 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(arg1: T1, arg2: T2) -&gt; T&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中<code>func()</code>就是喜闻乐见的函数名，而<code>T</code>则对应的是他的返回类型，括号里面则是函数需要传入的参数，类比到C++可以就像下面这样 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T1 arg1, T2 arg2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对于Rust的函数，他的返回值和参数的参数列表都是可选的，比如下面的代码就声明了一个不需要传入参数的函数 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>() -&gt; T&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 而下面这样则声明了一个没有返回值的函数 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(arg1:T)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 众所周知的是一个函数如果声明了返回类型后，其就必须有一个返回值。和大多数语言一样，rust可以使用<code>return</code>返回一个值，就像这样 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">return_one</span></span>() -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但是对于Rust来说，还有另外一种方式可以用来作为返回值使用，在多数情况下Rust的开发者们也更倾向使用这种方式进行返回，就像下面这样 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mul</span></span>(x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = x * y;</span><br><span class="line">    t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 我们可以看到的是函数内的最后一行的<code>t</code>后面并没有<code>;</code>，但是我们又知道Rust每行代码最后必然会有<code>;</code>。而在一个有返回值的函数中，通常这样的写法会出现在整个函数的末尾，他的含义等价于<code>return t;</code>。<br />
另外，Rust不止可以返回一个确定的变量，其同样可以将一个表达式作为返回值，就像下面这样 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mul</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个函数的功能等价于上一个<code>mul()</code>，但是它并没有声明一个中间变量<code>t</code>，而是选择直接返回<code>x*y</code>，这样的行为在Rust中是合法的，它同样可以实现目标功能而不会出现任何不可预期的问题。</p>
<h1 id="关于闭包">关于闭包</h1>
<p>Rust中也存在着一个类似于很多语言中所存在的lambda的存在，那就是闭包。<br />
闭包本质上是一个匿名的函数，其被广泛应用于Rust的多线程处理中，本节中不会讨论闭包，因为在整个Rust学习的前期闭包基本不会被提到。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的Rust生活：03-控制流与逻辑运算符</title>
    <url>/2020/11/27/Rust-03/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>作为一款合格的程序语言，基本的控制语句是必须有的，而对于Rust来说她的控制流语句相对于传统的语言来说都要更为丰富，本文将会大体地介绍Rust的各类控制语句及其的基本用法。</p>
<span id="more"></span>
<h1 id="if">if</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```rust</span><br><span class="line">if condition &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="match">match</h1>
<p>说到了<code>if</code>，自然少不了我们的好朋友<code>switch</code>，不过非常喜闻乐见的是Rust并没有<code>switch</code>，取而代之的是功能强大的<code>match</code>。<code>match</code>作为Rust中著名的条件选择语句，它不止用于多条件的判断控制，它还经常出现于<code>Option</code>的判断等等各类<code>None</code>类型或者错误处理的场景。常见的<code>match</code>的使用场景如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span>(item)&#123;</span><br><span class="line">    condition_1 =&gt; <span class="comment">//do something</span></span><br><span class="line">    condition_2 =&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    _=&gt; <span class="comment">//do default thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到Rust的<code>match</code>语句支持单行或者多行的情况，其中多行的情况必须使用大括号包起来，同时<code>match</code>同样有一个<code>_</code>分支，这个分支一般是作为default分支存在。有一点非常重要，所有分支的返回值类型必须相同。</p>
<p>但是前面又提到了<code>match</code>相对于<code>switch</code>更为强大，所以这里我们将会探讨之所以<code>match</code>强大的原因</p>
<h2 id="match可以作为表达式">match可以作为表达式</h2>
<p>在Rust中，match有一个非常常用的用法，在这种情况下所有的分支都必须要有返回值，就像这样</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">match</span> (item)&#123;</span><br><span class="line">    condition_1 =&gt; &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition_2 =&gt; &#123;</span><br><span class="line">        <span class="number">1</span> * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    _=&gt; &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下各个代码块最终的执行后的返回值将会被赋给<code>s</code></p>
<h2 id="match的分支条件可以用于解包各类enum">match的分支条件可以用于解包各类enum</h2>
<p>上面也说到了<code>match</code>可以用于处理<code>Option&lt;T&gt;</code>类型，在Rust中我们可以这样用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span>(s)&#123;</span><br><span class="line">    <span class="literal">Some</span>(x) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;is none&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 输出5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就像这样，Rust可以利用<code>match</code>语句轻松地解决<code>Option&lt;T&gt;</code>类型的问题。</p>
<h1 id="后记">后记</h1>
<p>在写了四篇Rust的博客之后，我突然发现自己对Rust的理解非常的零散肤浅，所以从本篇开始《从零开始的Rust生活》系列将会暂时停更，待到我更加了解Rust后再继续进行更新。接下来本博客将会开始逐步更新本人的Rust学习记录，同步于本人的Rust的学习进程。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title>信号量机制与管程</title>
    <url>/2020/11/18/Semaphore-and-Monitor/</url>
    <content><![CDATA[<h1 id="信号量机制">信号量机制</h1>
<p>信号量机制最早由提出图论的Dijkstra提出，其被广泛地使用于操作系统中用于解决同步问题。</p>
<h2 id="信号量简介">信号量简介</h2>
<p>信号量一般由以下几部分组成</p>
<ul>
<li>一个整形<code>sem</code><br />
通常<code>sem</code>的值等于共享资源的数量</li>
<li>两个操作
<ul>
<li>P操作(又名Wait)<br />
P操作通常用于申请资源，其的主要过程一般为
<ul>
<li><code>sem -= 1</code></li>
<li>当<code>sem &lt; 0</code>block当前进(线)程，并放入等待队列中</li>
</ul></li>
<li>V操作(又名Signal)<br />
V操作通常用于释放资源，其的主要过程一般为
<ul>
<li><code>sem += 1</code></li>
<li>当<code>sem &lt;=0</code>时从等待队列中取出一个进(线)程，并唤醒</li>
</ul></li>
</ul></li>
</ul>
<p>借助信号量机制，我们可以解决很多的多进(线)程间同步的问题。接下来我们将会使用几个例子来进一步地了解信号量的作用。</p>
<span id="more"></span>
<h2 id="生产者-消费者问题">生产者-消费者问题</h2>
<p>生产者-消费者问题是一个非常著名的多线程间同步的问题，接下来我们将会围绕这个问题探讨信号量机制的意义。</p>
<p>首先我们假设现在我们有一个盒子，x个消费者和y个生产者。并且我们规定同时可以有消费者从盒子中取出东西，同时只能由一位生产者向盒子中放入东西，且消费者和生产者同样不能同时从盒子中取出或者放入东西。</p>
<h3 id="情景0多消费者-无生产者-盒子内的资源无限">情景0：多消费者-无生产者-盒子内的资源无限</h3>
<p>情景0并不是定义上的生产者-消费者问题，这种情况只是提出用于具体了解信号量的工作方式的情景，故在本情景中我们假设同时只能有一位消费者从盒子中取出东西。<br />
这种情况实际上可以退化为多个等价的个体竞争一个资源的情况，由于我们规定了盒子同时只能由一位消费者进行访问，所以我们这里就可以使用一个信号量表示盒子的占用情况，由上文中的信号量的定义我们可以得知当任何消费者对盒子进行访问后下一次对<code>res.wait()</code>的调用就会将新的进程阻塞，直到访问盒子的消费者调用<code>res.signal()</code>进行唤醒。 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res: Semaphore = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consumer</span></span>()&#123;</span><br><span class="line">    res.wait();</span><br><span class="line">    <span class="comment">//对盒子中的资源进行消费</span></span><br><span class="line">    res.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="情景1单消费者-单生产者-盒子容量为一">情景1：单消费者-单生产者-盒子容量为一</h3>
<p>从情景1开始才是真正意义上的消费者生产者问题，但是这里我们还是限制了消费者和生产者的数量均为1。对于本情景中的条件，我们可以构造得到下述的伪代码 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> full: Semaphore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> empty: Semaphore = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consumer</span></span>()&#123;</span><br><span class="line">    full.wait();</span><br><span class="line">    <span class="comment">//对盒子内的资源进行消费</span></span><br><span class="line">    empty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">provider</span></span>()&#123;</span><br><span class="line">    empty.wait();</span><br><span class="line">    <span class="comment">//向盒子中生产内容</span></span><br><span class="line">    full.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面的代码就可以看到我们创建了两个信号量而非一个，原因也很简单，当盒子为空的时候消费者无法进行消费，当盒子为满的时候生产者无法进行生产，所以我们就可以让消费者对<code>full</code>作<code>wait()</code>标志空间已经被释放，同样生产者也可以使用<code>full.signal()</code>实现标志盒子中已经放入了资源。</p>
<h3 id="情景2多消费者-单生产者-盒子容量为n">情景2：多消费者-单生产者-盒子容量为n</h3>
<p>现在我们引入了多个消费者，我们知道当任何消费者在访问盒子的时候生产者都不能朝盒子中放入东西，但是我们只需要对上面的代码稍作修改即可解决这个问题。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> full: Semaphore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> empty: Semaphore = n;</span><br><span class="line"><span class="keyword">let</span> mutex: Semaphore = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> using: Semaphore = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> count: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consumer</span></span>()&#123;</span><br><span class="line">    full.wait();<span class="comment">//当盒中有资源的时候</span></span><br><span class="line">    mutex.wait();<span class="comment">//当生产者未占用(盒子空闲)</span></span><br><span class="line">    using.wait();</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    using.signal();</span><br><span class="line">    <span class="comment">//从此处才正式开始消费</span></span><br><span class="line">    empty.signal();</span><br><span class="line">    <span class="comment">//从盒子中取出资源</span></span><br><span class="line">    using.signal();</span><br><span class="line">    using.wait();</span><br><span class="line">    count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>&#123;</span><br><span class="line">        mutex.signal();<span class="comment">//当所有消费者退出之后才释放mutex</span></span><br><span class="line">    &#125;</span><br><span class="line">    using.signal();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">provider</span></span>()&#123;</span><br><span class="line">    empty.wait();<span class="comment">//当盒子还有空间的时候</span></span><br><span class="line">    mutex.wait();<span class="comment">//当消费者未占用(盒子空闲)</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="comment">//向盒子中放入东西</span></span><br><span class="line">        full.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.signal();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看到这里我们加入了两个信号量，一个负责控制消费者和生产者分别对共享的盒子的访问，另外一个用于控制消费者的计数器。<br />
在上面的代码中我们实际上将多个消费者和单一生产者的问题抽象为了第一个消费者和生产者之间的问题，当消费者全部完成消费并退出之后我们才会释放掉<code>mutex</code>使得生产者可以向盒子中放入东西。同时务必要记住在多进(线)程对共享变量的操作中必须要使用信号量管理访问的权限。</p>
<h1 id="管程">管程</h1>
<p>管程实际上是一种对同步锁抽象得到的数据结构，一般来说管程有以下几种特征 - 同时只允许一个进(线)程在管程中执行 - 使用条件变量管理管程内进(线)程的执行 - 拥有一个<strong>入口队列</strong>用于进(线)程排队进行管程</p>
<p>实际上在本菜鸡看来管程的确有点难以理解，尤其是其的基本结构和几种不同的实现方式。</p>
<h2 id="条件变量">条件变量</h2>
<p>管程采用条件变量控制已经进入管程的进程的执行，条件变量本身的各种特征又和信号量有点相似但是完全不同 - <code>wait()</code>操作 - 表示当资源被占用导致自身阻塞，并将自身放入等待队列 - 执行<code>wait()</code>后将会从入口队列中唤醒一个新的进(线)程 - <code>signal()</code>操作 - 表示当前资源已经被使用完毕，唤醒等待队列中的一个进(线)程 - 当等待队列为空的时候<code>signal()</code>操作没有意义</p>
<p>这里我们就可以清楚地看到条件变量和信号量的区别，对于条件变量来说由于调用其的进(线)程已经在管程中，故其的<code>wait()</code>和<code>signal()</code>无需成对，且在条件变量执行完成<code>wait()</code>操作后进(线)程必定阻塞，但是对于信号量的<code>V()</code>操作则不一定会阻塞。且在条件变量执行<code>wait()</code>操作或<code>signal()</code>的时候已经默认获得了互斥锁。</p>
<p>光谈概念感觉管程本身还是比较晦涩的，下面还是会用著名的读者-写者问题讨论管程</p>
<h2 id="使用管程实现读者-写者问题">使用管程实现读者-写者问题</h2>
<p>通过使用管程，我们可以将读者-写者问题包装为一个面向对象的类 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Database</span></span>&#123;</span><br><span class="line">    lock: Lock,</span><br><span class="line">    AC: <span class="built_in">i32</span>, <span class="comment">//已经激活的读者</span></span><br><span class="line">    AP: <span class="built_in">i32</span>, <span class="comment">//已经激活的写者</span></span><br><span class="line">    WC: <span class="built_in">i32</span>, <span class="comment">//正在等待的读者</span></span><br><span class="line">    WP: <span class="built_in">i32</span>, <span class="comment">//正在等待的写者</span></span><br><span class="line">    buffer: <span class="built_in">i32</span>,</span><br><span class="line">    Condition okToRead, okToWrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Database&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">start_consume</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.lock.aquire();</span><br><span class="line">        <span class="keyword">if</span> (WP + AP) &gt; <span class="number">0</span>&#123; <span class="comment">// 相当于还有写者处于激活状态的时候</span></span><br><span class="line">            WC++;</span><br><span class="line">            okToRead.wait(<span class="keyword">mut</span> <span class="keyword">self</span>.lock); <span class="comment">// 将自己阻塞</span></span><br><span class="line">            WC--;</span><br><span class="line">        &#125;</span><br><span class="line">        AC++;<span class="comment">//此处为未阻塞或者被唤醒</span></span><br><span class="line">        <span class="keyword">self</span>.lock.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">end_consume</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.lock.aquire();</span><br><span class="line">        AC--;</span><br><span class="line">        <span class="keyword">if</span> AC == <span class="number">0</span> &amp;&amp; WP &gt; <span class="number">0</span>&#123;</span><br><span class="line">            okToWrite.signal(); <span class="comment">// 当激活的读者退出的时候唤醒阻塞在队列中的写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.lock.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">start_produce</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.lock.aquire();</span><br><span class="line">        <span class="keyword">if</span> (WC + AC) &gt; <span class="number">0</span>&#123;</span><br><span class="line">            WP++;</span><br><span class="line">            okToWrite.wait(<span class="keyword">mut</span> <span class="keyword">self</span>.lock); <span class="comment">// 同样当任何读者在执行的时候将自身阻塞</span></span><br><span class="line">            WP--;</span><br><span class="line">        &#125;</span><br><span class="line">        AP++; <span class="comment">//此处为未阻塞或者被唤醒</span></span><br><span class="line">        <span class="keyword">self</span>.lock.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">end_produce</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.lock.aquire();</span><br><span class="line">        AP--;</span><br><span class="line">        <span class="keyword">if</span> AP == <span class="number">0</span> &amp;&amp; WC &gt; <span class="number">0</span>&#123;</span><br><span class="line">            okToRead.signal(); <span class="comment">// 当激活的写者退出的时候唤醒正在排队的读者线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.lock.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.start_consume();</span><br><span class="line">        <span class="comment">// do consume</span></span><br><span class="line">        <span class="keyword">self</span>.end_consume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.start_produce();</span><br><span class="line">        <span class="comment">// do produce</span></span><br><span class="line">        <span class="keyword">self</span>.end_produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们使用了四个整形变量、一个锁和两个条件变量完成了对消费者-生产者的控制，我们可以看到对于读和写操作我们均使用两个函数来完成其的同步控制。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包系列问题</title>
    <url>/2021/05/23/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题简介">问题简介</h2>
<p>多重背包问题相对于完全背包问题最大的区别在于多重背包问题中每个物品的数量是有限的，但是二者的状态转移方程相同，故其可以由完全背包问题改写而来。</p>
<p>但是直接改写而来的朴素版本的完全背包问题本身无法应对较大的数据范围，故需要适当进行优化，本文便是针对该类常规的多重背包问题进行解答。</p>
<span id="more"></span>
<h2 id="acwing-5.多重背包问题ii">AcWing 5.多重背包问题II</h2>
<p>当数据范围较小的时候可以考虑进行<strong>二进制优化</strong>，即将一组n个物品拆分为1个、2个、4个...，将问题转化为了01背包问题，即可以解决。</p>
<p>该问题的基本原理在于2的k次方可以表达出<span class="math inline">\(0\)</span>到<span class="math inline">\(2^k - 1\)</span>范围内的所有数字，故可以得到该种划分方式。</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, V, idx;</span><br><span class="line"><span class="keyword">int</span> cnt[N], w[N], v[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tc, tw, tv;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; tc;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> amt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(amt &lt;= tc)</span><br><span class="line">        &#123;</span><br><span class="line">            tc -= amt;</span><br><span class="line">            w[idx] = tw * amt;</span><br><span class="line">            v[idx] = tv * amt;</span><br><span class="line">            amt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            idx ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tc != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            w[idx] = tw * tc;</span><br><span class="line">            v[idx] = tv * tc;</span><br><span class="line">            idx ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="acwing-6.多重背包问题3">AcWing 6.多重背包问题3</h2>
<p>该问题中数据规模进一步扩大，原始的方法已经无法满足需求，故此时我们可以尝试去寻找规律去分析该问题。</p>
<p>首先我们可以将各个状态列出进行观察，有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i, j] 		= max(f[i - 1, j], f[i - 1, j - v] + w, f[i - 1, j - 2v] + 2w ... f[i - 1, j - sv] + sw)</span><br><span class="line">f[i, j - v] = max(             f[i - 1, j - v],     f[i - 1, j - 2v] + w ...  f[i - 1, j - sv] + (s - 1)w + f[i - 1, j - (s + 1)v] + sw)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到我们假设将物品全部选中后依旧不会超出容量的最大限制，此时<code>f[i, j]</code>与<code>f[i, j - v]</code>并不能如同完全背包问题那样对齐，故我们需要考虑其他的方法来解决这个问题。</p>
<p>当然，当我们列出剩下的每一项后我们可以发现一个规律，即该问题实际上是一个滑动窗口求最大值问题，即按照上面的对齐方式可以看出实际上<code>f[i, j]</code>除去第一项之后剩余项实际上可以看作是<code>f[i, j - v]</code>对应的窗口向固定方向滑动了一步。故根据这个特性我们便可以完成该题。可以考虑将上面的<code>-</code>更换为<code>+</code>，即从小到大递增。</p>
<p>但是此时我们还需要解决关于单调队列中偏移量的问题，在原始的式子中我们可以看到所有项后面都带着一个偏移量，而在单调队列转换的过程中就会出现单调队列最前方的项每次都需要+w的情况，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][j] = max(f[i - 1][j])</span><br><span class="line">f[i][j + v] = max(f[i - 1][j] + w, f[i - 1][j + v])</span><br><span class="line">f[i][j + 2v] = max(f[i - 1][j] + 2w, f[i - 1][j + v] + w, f[i - 1][j + 2v])</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>故可以考虑转换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i, j] = max(f[i - 1, j] - sw, s[i - 1, j - v] - (s - 1)w, ..., f[i - 1, j - sv]) + sw</span><br></pre></td></tr></table></figure>
<p>即此时我们的单调队列可以转换为针对转换后<code>max()</code>函数内的各项求单调队列，然后将总体的偏移量加回。</p>
<p>实际上最后我们的式子就被转换成了这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][j]      = max(f[i - 1][j])</span><br><span class="line">f[i][j + v]  = max(f[i - 1][j], f[i - 1][j + v] - w) + w</span><br><span class="line">f[i][j + 2v] = max(f[i - 1][j], f[i - 1][j + v] - w, f[i - 1][j + 2v] - 2w) + 2w;</span><br><span class="line">...</span><br><span class="line">f[i][j + nv] = max(f[i - 1][j + (n - s)v], f[i - 1][j + (n - s + 1)v] - w, ... f[i - 1][j + nv] - sv) + sv</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-1">代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N], g[N], q[N];</span><br><span class="line"><span class="keyword">int</span> v, w, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= m; k += v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ; <span class="comment">// 注意这里的k代表了总体积，即当k - s * v大于了队头保存的体积时将会弹出队头</span></span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ; <span class="comment">// 将队列尾部所有小于当前值的元素统统删除</span></span><br><span class="line">                q[ ++ tt] = k;</span><br><span class="line">                f[k] = g[q[hh]] + (k - q[hh]) / v * w; <span class="comment">// 将偏移量加回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法学习</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁与银行家算法</title>
    <url>/2020/11/19/%E6%AD%BB%E9%94%81%E4%B8%8E%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="死锁">死锁</h1>
<p>死锁作为多进(线)程开发中经常遇到的问题，其通常体现为多个进程和线程同时处于阻塞状态并且在没有任何外力干扰的情况下完全无法解除这种状态的情况。我们可以通过一个著名的场景来具体地理解死锁的概念。</p>
<span id="more"></span>
<h2 id="哲学家用餐问题">哲学家用餐问题</h2>
<p>哲学家用餐问题主要模型在一个<strong>圆桌</strong>上坐着n位哲学家，而每位哲学家的间隔处均放着一只筷子，所有的哲学家均处拥有进餐和思考两种状态，其中如果希望进入用餐状态则需要同时获得左右两边的筷子。<br />
现在假设总共有5个哲学家，对应的就是5只筷子，画成图就如下所示 <img src="https://i.loli.net/2020/11/19/5BZeJAtpYKHfzuS.png" alt="image.png" /> 这张图来自于维基百科<a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a>,故筷子变成了叉子，将就看看吧(笑)</p>
<h3 id="哲学家用餐问题与死锁">哲学家用餐问题与死锁</h3>
<p>现在我们要在这个问题中引入死锁的问题，我们假设所有的哲学家同时希望就餐，此时他们同时拿起了他们左侧的筷子(叉子)，由于这群哲学家都是自私自利的，他们在成功就餐之前<strong>不会放弃</strong>手上的筷子(叉子)，故接下来他们在请求自己右边的叉子的时候所有的哲学家都不会获得在他们右手的筷子(叉子)，因为右边的筷子(叉子)均被他们各自右边的哲学家取走了，所以从这个时刻开始所有的哲学家均无法就餐，由于他们都不愿意放弃手上已经获得的筷子(叉子)，所以没有人会打破这个僵局，也就是说现在发生了<strong>死锁</strong></p>
<h3 id="常规的解决方案">常规的解决方案</h3>
<p>由于哲学家问题涉及到的请求的资源种类单一，我们可以使用在之前学到的信号量机制轻松地解决这个问题。</p>
<h4 id="服务生机制">服务生机制</h4>
<p>第一种方法就是引入一个服务生，当哲学家需要进餐的时候他们将不会自己拿起自己的筷子(叉子)，而是由服务生检查他两侧是否有筷子(叉子)，如果都有的时候便由服务生拿起两侧的餐具交给这位哲学家，这样实现了在请求资源之前对资源进行检查，防止出现死锁的情况。 我们可以用伪代码实现如下，我们将会对哲学家进行编号，顺时针0-4，其中0号哲学家左边的筷子视作0号筷子，右边为1号，依次递增。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> waiter: Semaphore = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> fork: <span class="built_in">Vec</span>&lt;Semaphore&gt; = [<span class="number">1</span>; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">philosopher</span></span>(code:<span class="built_in">i32</span>)&#123;</span><br><span class="line">    waiter.wait();</span><br><span class="line">    <span class="keyword">let</span> ready = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> fork[left].available() and fork[right].available()&#123;</span><br><span class="line">        fork[left].wait();</span><br><span class="line">        fork[right].wait();</span><br><span class="line">    &#125;</span><br><span class="line">    waiter.signal();</span><br><span class="line">    <span class="keyword">if</span> ready&#123;</span><br><span class="line">        <span class="comment">//进餐</span></span><br><span class="line">        fork[left].signal();</span><br><span class="line">        fork[right].signal():</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//左右筷子被占用，无法就餐</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="轮流进餐机制">轮流进餐机制</h4>
<p>第二种方法便是要求每次只能由一个哲学家要求进餐，也就是说当某个哲学家宣布自己要进餐的时候其他所有人都不能对自己身边的餐具进行请求，只能由要求进餐的这位哲学家拿起自己两侧的餐具进行就餐，就餐完毕之后其他人才能再次宣布自己要就餐。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> house: Semaphore = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> fork: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = [<span class="number">1</span>; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">philosopher</span></span>(code: <span class="built_in">i32</span>)&#123;</span><br><span class="line">    house.wait();</span><br><span class="line">    fork[left] = <span class="number">0</span>;</span><br><span class="line">    fork[right] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//就餐</span></span><br><span class="line">    fork[left] = <span class="number">1</span>;</span><br><span class="line">    fork[right] = <span class="number">1</span>;</span><br><span class="line">    house.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="死锁的概念">死锁的概念</h2>
<p>从上面的问题，相信读者也对死锁有了一定的概念，对于死锁来说其自身的产生实际上有四个必要条件，而后续探讨的系统性的对死锁的解决同样基于这四个必要条件进行</p>
<ul>
<li>互斥条件：多个线程之间请求的资源具有互斥性</li>
<li>不可剥夺条件：线程请求的资源是不可剥夺的</li>
<li>持有请求条件：当一个线程持有一个或多个资源的同时其会去请求其他线程所占有的资源，引起阻塞</li>
<li>循环等待条件：多个线程同时发生持有等待，同时这些线程持有的资源与请求的资源可以形成一个环。</li>
</ul>
<h2 id="死锁的解决">死锁的解决</h2>
<h3 id="预防死锁">预防死锁</h3>
<p>预防死锁实际上是最低效，最暴力，但是最简单的方法，其通过分别破坏死锁的四种条件完成对死锁的预防。</p>
<ul>
<li>互斥条件：其作为系统的基本特征，<strong>无法破坏</strong></li>
<li>持有请求条件：要求进程在创建时需要申请全部的资源，如果不满足的话直接阻止进程的创建</li>
<li>不可剥夺条件：要求进程在全部资源全部申请成功后才能执行，否则将进程阻塞</li>
<li>循环等待条件：按序申请，相当于对所有资源进行编号，进程在申请资源的时候必须严格按照序号进行申请</li>
</ul>
<h3 id="避免死锁">避免死锁</h3>
<p>避免死锁相对于预防死锁来说性能更好，其的基本流程为判断申请资源的时候是否有死锁风险，如果没有的话则授予资源，否则阻塞进程直到资源可用。</p>
<h4 id="安全与不安全的划分">安全与不安全的划分</h4>
<p>当系统按照一定的顺序调度进程，如<span class="math inline">\(P_1, P_2, P_3...P_n\)</span>，对于其中任何一个进程<span class="math inline">\(P_i\)</span>均应当满足其所请求资源的最大需求，此时则视为安全，否则视为不安全。<br />
此时，我们就需要构建一个算法用来计算得到这样一个进程序列。同时由于系统中的进程实际上是不断地在申请和释放资源的，故实际上系统的安全和不安全其实是在反复切换的。</p>
<h4 id="银行家算法">银行家算法</h4>
<p>银行家算法便是一种著名的用于实现避免死锁的算法。</p>
<h5 id="数据结构">数据结构</h5>
<ul>
<li>可用的资源量：<code>Available</code>，长度为n的向量</li>
<li>最大需求矩阵：<code>Max</code>，n行m列的矩阵</li>
<li>分配矩阵：<code>Allocation</code>，n行m列的矩阵</li>
<li>需求矩阵：<code>Need</code>，n行m列的矩阵</li>
<li>资源请求向量：<code>Request</code>，长度为m的向量，且<code>Request_i[j]</code>表示i进程对j资源的需求量</li>
</ul>
<p>其中<code>Max = Allocation + Need</code></p>
<h5 id="算法过程">算法过程</h5>
<p>当进程i提出了Request_i的时候，将会执行以下操作</p>
<ol type="1">
<li>若<code>Request_i &gt; Need[i]</code>，出错</li>
<li>若<code>Request_i &gt; Available</code>，进程被阻塞</li>
<li>当上述两步均通过，则开始试分配
<ol type="1">
<li><code>Available -= Request_i</code></li>
<li><code>Allocation[i] += Request_i</code></li>
<li><code>Need[i] -= Request_i</code></li>
</ol></li>
<li>允许安全性检测算法</li>
<li>若第4步得到了一个安全的调度序列，则视作安全，分配内存，否则撤销该次预分配</li>
</ol>
<h5 id="安全性检测">安全性检测</h5>
<p>在这一步中我们将会引入两个向量，分别为</p>
<ul>
<li><code>work</code>向量，长度为n，其作为<code>Available</code>的一个替身</li>
<li><code>finish</code>向量，长度为m，其用于标记各进程的满足情况，初始化为全<code>false</code></li>
</ul>
<p>接下来我们需要按照如下的方式来对<code>finish</code>进行迭代<br />
1. 找到一个同时满足<code>finish[i] = false</code>且<code>Need[i] &lt; work</code>的进程<code>i</code>，假定其很快就会完成他的工作并归还资源，然后进行<code>work += Allocation[i]</code>和<code>finish[i] = true</code>，若找不到，则到第3步 2. 回到第1步 3. 如果<code>finish</code>全部为<code>true</code>则说明安全，反之则为不安全</p>
<h1 id="总结">总结</h1>
<p>对于常规条件下的死锁问题，我们还会有很多的解决方案，包括上面提到的哲学家死锁问题，同样也还有其他的解法，本文的目的只在于介绍死锁问题和银行家算法。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
